<!DOCTYPE html>

<html lang="en">

<head>
    <!-- Page information -->
    <meta charset="UTF-8" />
    <meta name="node_id" content="tech yourself computer science" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" href="/favicon.ico" />

    <!-- Set title -->
    <title>Inom's working notes</title>

    <!-- Includes -->
    
<script src="/obs.html/static/obsidian_core.js"></script>
<script src="/obs.html/static/encoding.js"></script>
<link rel="stylesheet" href="/obs.html/static/master.css" />
<script src="/obs.html/static/mermaid.9.0.1.min.js"></script>
<script>
  MathJax = {
    loader: {
      load: [
        '[tex]/action',
        'output/chtml',
        '[tex]/centernot'
      ]
    },
    tex: {
      inlineMath: [ ["\\(","\\)"] ],
      displayMath: [ ["\\[","\\]"] ],
      processEscapes: true,
      processEnvironments: true,
      packages: {'[+]': ['centernot']}
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
<script src="/obs.html/static/flexsearch.bundle.js"></script>
<script src="/obs.html/static/pako.js"></script>
<script src="/obs.html/static/search.js"></script>
<script src="/obs.html/static/dirtree.js"></script>


    <!-- Onload tweaks -->
    <script>
        const CURRENT_NODE = "tech yourself computer science";
        const HTML_URL_PREFIX = "";
        const PAGE_DEPTH = 0;
    </script>

    <style>
        /* Critical CSS */
        html{
            background: #000;
        }

        body,
        .container,
        code {
            font-size: 18pt;
            font-family: monospace, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            max-width: calc(81ch + 64px);
            margin: 0 auto;
        }

        .container {
            max-width: 81ch;
        }

        ::-webkit-scrollbar {
            width: 0.6rem;
            height: 0.6rem;
        }

        ::-webkit-scrollbar-thumb {
            border: 0px;
            border-radius: 10px;
        }

        .theme-obs-light .left_pane, .theme-obs-light .right_pane,
        .theme-obs-dark .left_pane, .theme-obs-dark .right_pane,
        .theme-obs-dark .container, .theme-obs-light .container, .theme-obs-dark
        .container_filler, .theme-obs-light .container_filler {
            border-top: 0;
        }

        code {
            line-height: 1.2;
            font-family: monospace, "SourceCodePro-Regular";
        }

        h1 {
            font-size: 24pt;
            font-style: italic;
        }

        h2 {
            font-size: 24pt;
        }

        h3 {
            font-size: 18pt;
        }

        h4 {
            font-size: 15pt;
        }

        .dir-list li,
        h5 {
            font-size: 12pt;
        }

        h6 {
            font-size: 9pt;
        }
    </style>
</head>

<body class="theme-obs-light">
    <div id="antiflash" style="display: none"></div>
    <script>
        document.getElementById("antiflash").style.display = "block";
    </script>
    <div id="search-master-div">
    <div id="search-slab" king_ramses="return the slaaab">
            <div id="search-controls">
                    <input id="search_string" placeholder="Type to search notes" type="text" />
                    <div class="tooltip" style="display: none;">
                        <input type="checkbox" id="hard_search" name="hard" />
                        <span class="tooltiptext">Hard search (require exact match)</span>
                    </div>
                    <div id="search-results-box">
                        <div id="search-results"></div>
                    </div>
                    <div id="search-instructions">
                        <div class="prompt-instruction">
                                <b>esc</b> to dismiss
                        </div>
                    </div>
            </div>
    </div>
</div>

<script>
    document.getElementById("search-master-div").addEventListener('click', e => {
            if(e.target !== e.currentTarget){
                    return
            }
            toggle_id('search-master-div');
    })
    document.getElementById("search_string").addEventListener("input", function(event) {
            setTimeout( () =>run_search('search_string', 'hard_search'), 100 );
    }); 
    document.getElementById("hard_search").addEventListener("click", function(event) {
            setTimeout( () =>run_search('search_string', 'hard_search'), 100 );
    });

    window.addEventListener('keydown', e => {
        if((e.key=='Escape'||e.key=='Esc'||e.keyCode==27)){
            toggle_id('search-master-div');
            return false;
        } 
    }, true);

    function click_list_link(element){
        element.parentElement.getElementsByTagName('a')[0].click()
    }
</script>

    <div id="page_holder" class="flex_col">
        <div id="header" class="header">
    <div id="header_flex" class="flex_row">
            <a href="/index.html" id="homelink" title="Clear screen and go to homepage">Inom's working notes</a>
            <div id="menu_toggle_button" class="navbar-button requires_js" onclick="toggle_menu()">
                    ‚â°
            </div>
            <div id="navbar" class="navbar requires_js">
                    
                    <div class="icon-tray">
                            <div id="theme-button" class="theme-button requires_js" title="Change theme" onclick="toggle_theme_popup(this)">
    T
</div>
<script>
    function toggle_theme_popup(el){
        // make theme button show that it's active by adding the .active class
        toggle(el);

        // show the theme selector
        toggle_id('theme-popup')

        let h2 = document.getElementById('header2')
        if (h2){
            let pu = document.getElementById('header2').getElementsByClassName('popup')[0];
            toggle(pu);
        }
    }

    function disable_theme_popup(){
        disable_id('theme-button');

        // show the theme selector
        disable_id('theme-popup')

        let h2 = document.getElementById('header2')
        if (h2){
            let pu = document.getElementById('header2').getElementsByClassName('popup')[0];
            disable(pu);
        }
    }
</script>
                                    <div onclick="openSearch()" class="theme-button requires_js">
            <img src = "/obs.html/static/search.svg" alt="Search notes" title="Search notes" style="margin: 4px;"/>
        </div>
        <script>
            function openSearch(){
                // toggle search popup and continue with extra code if it is enabled this time
                if (toggle_id('search-master-div')){
                    // get input field and temporarily disable it
                    let ss = document.getElementById('search_string');
                    ss.value = 'Seach data initializing...';
                    ss.readOnly = true; 

                    // load search data if not yet done so
                    setTimeout(function(){
                        LoadSearchData()

                        // clear input and put focus on it so that we can start typing immediately
                        ss.value = '';
                        ss.readOnly = false; 
                        ss.focus()
                        ss.select()
                    }, 100);
                }
            }
        </script>
                                    <div class="graph_header_div requires_js">
            <a id="graph_link" class="system-link" href="/obs.html/graph/index.html?node=tech yourself computer science" title="Open fullpage Graph">
                    <img class="graph_header_div_svg" src = "/obs.html/static/graph.svg" alt="Open fullpage Graph" style="margin: 2px; width: 17px;"/>
            </a>
        </div>
                                    <div >
            <a id="dirtree_link" class="system-link" href="/obs.html/dir_index.html" title="View directory tree">
                    <img src = "/obs.html/static/dirtree.svg" style="width: 12px; padding: 4px;" alt="Directory tree link"/>
            </a>
        </div>
                            <div>
    <a href="/obs.html/tags/index.html" title="Open tag view">
            <img src = "/obs.html/static/hashtag.svg" alt="RSS Feed link" style="width: 24px; margin-left: -2px; margin-top: -2px;"/>
    </a>
</div>
                            
                    </div>
                    <div style="display: flex; flex-direction:column">
                        <div id="left_pane_toggle_nav" class="left_pane_toggle_nav">Toggle Directory Tree Pane</div>
                        <div id="right_pane_toggle_nav" class="right_pane_toggle_nav">Toggle Table of Contents Pane</div>
                    </div>
            </div>
    </div>
    <div class="popup" id="theme-popup">
    <label for="cars">Theme </label>

    <select name="theme" id="theme" onchange="set_theme(this.value)">
      <option value="light">light</option>
      <option value="obs-light" selected="selected">obsidian-light</option>
      <option value="obs-dark">obsidian-dark</option>
    </select> 
</div>
</div>
        <div class="flex_row">
            
            <div class="container">
                <div class="content"><h1 id="teach-yourself-computer-science">Teach Yourself Computer Science</h1>
<p>If you‚Äôre a self-taught engineer or bootcamp grad, you owe it to yourself to
learn computer science. Thankfully, you can give yourself a world-class CS
education without investing years and a small fortune in a degree program üí∏.</p>
<p>There are plenty of resources out there, but some are better than others. You
don‚Äôt need yet another ‚Äú200+ Free Online Courses‚Äù listicle. You need answers to
these questions:</p>
<ul>
<li><strong>Which subjects</strong> should you learn, and why?</li>
<li>What is the <strong>best book or video lecture series</strong> for each subject?</li>
</ul>
<p>This guide is our attempt to definitively answer these questions.</p>
<p>Thank you to the following volunteers for translations:</p>
<ul>
<li><a href="https://github.com/ilmoi/teachyourselfCS-RU/blob/master/Teach_yourself_cs-2020-RU.md" class="external-link">–ü–µ—Ä–µ–≤–æ–¥ –Ω–∞ –†—É—Å—Å–∫–æ–º</a>
  (Russian) by Ilja Moisejevs and Stepan Rakitin</li>
</ul>
<p>NOTE: ... other translations removed</p>
<h2 id="tl-dr">TL;DR:</h2>
<p>Study all nine subjects below, in roughly the presented order, using either the
suggested textbook or video lecture series, but ideally both. Aim for 100-200
hours of study of each topic, then revisit favorites throughout your career üöÄ.</p>
<ul>
<li>Subject: <a href="#programming" class="anchor-link">Programming</a></li>
<li>Why study? Don‚Äôt be the person who ‚Äúnever quite understood‚Äù something like recursion.</li>
<li>Book: <em>Structure and Interpretation of Computer Programs</em></li>
<li>
<p>Videos: Brian Harvey‚Äôs Berkeley CS 61A</p>
</li>
<li>
<p>Subject: <a href="#architecture" class="anchor-link">Computer Architecture</a></p>
</li>
<li>Why study? If you don‚Äôt have a solid mental model of how a computer actually works, all of your higher-level abstractions will be brittle.</li>
<li>Book: <em>Computer Systems: A Programmer's Perspective</em></li>
<li>
<p>Videos: Berkeley CS 61C</p>
</li>
<li>
<p>Subject: <a href="#algorithms" class="anchor-link">Algorithms and Data Structures</a></p>
</li>
<li>Why study? If you don‚Äôt know how to use ubiquitous data structures like stacks, queues, trees, and graphs, you won‚Äôt be able to solve challenging problems.</li>
<li>Book: <em>The Algorithm Design Manual</em></li>
<li>
<p>Videos: Steven Skiena‚Äôs lectures</p>
</li>
<li>
<p>Subject: <a href="#math" class="anchor-link">Math for CS</a></p>
</li>
<li>Why study? CS is basically a runaway branch of applied math, so learning math will give you a competitive advantage.</li>
<li>Book: <em>Mathematics for Computer Science</em></li>
<li>
<p>Videos: Tom Leighton‚Äôs MIT 6.042J</p>
</li>
<li>
<p>Subject: <a href="#operating-systems" class="anchor-link">Operating Systems</a></p>
</li>
<li>Why study? Most of the code you write is run by an operating system, so you should know how those interact.</li>
<li>Book: <em>Operating Systems: Three Easy Pieces</em></li>
<li>
<p>Videos: Berkeley CS 162</p>
</li>
<li>
<p>Subject: <a href="#networking" class="anchor-link">Computer Networking</a></p>
</li>
<li>Why study? The Internet turned out to be a big deal: understand how it works to unlock its full potential.</li>
<li>Book: <em>Computer Networking: A Top-Down Approach</em></li>
<li>
<p>Videos: Stanford CS 144</p>
</li>
<li>
<p>Subject: <a href="#databases" class="anchor-link">Databases</a></p>
</li>
<li>Why study? Data is at the heart of most significant programs, but few understand how database systems actually work.</li>
<li>Book: <em>Readings in Database Systems</em></li>
<li>
<p>Videos: Joe Hellerstein‚Äôs Berkeley CS 186</p>
</li>
<li>
<p>Subject: <a href="#languages" class="anchor-link">Languages and Compilers</a></p>
</li>
<li>Why study? If you understand how languages and compilers actually work, you‚Äôll write better code and learn new languages more easily.</li>
<li>Book: <em>Crafting Interpreters</em></li>
<li>
<p>Videos: Alex Aiken‚Äôs course on edX</p>
</li>
<li>
<p>Subject: <a href="#distributed-systems" class="anchor-link">Distributed Systems</a></p>
</li>
<li>Why study? These days, most systems are distributed systems.</li>
<li>Book: <em>Designing Data-Intensive Applications</em> by Martin Kleppmann</li>
<li>Videos: MIT 6.824</li>
</ul>
<h2 id="still-too-much">Still too much?</h2>
<p>If the idea of self-studying 9 topics over multiple years feels overwhelming, we
suggest you focus on just two books: <em>Computer Systems: A Programmer's
Perspective</em> and <em>Designing Data-Intensive Applications</em>. In our experience,
these two books provide incredibly high return on time invested, particularly
for self-taught engineers and bootcamp grads working on networked applications.
They may also serve as a "gateway drug" for the other topics and resources
listed above.</p>
<h2 id="why-learn-computer-science">Why learn computer science?</h2>
<p>There are 2 types of software engineer: those who understand computer science
well enough to do challenging, innovative work, and those who just get by
because they‚Äôre familiar with a few high level tools.</p>
<p>Both call themselves software engineers, and both tend to earn similar salaries
in their early careers. But Type 1 engineers progress toward more fulfilling and
well-remunerated work over time, whether that‚Äôs valuable commercial work or
breakthrough open-source projects, technical leadership or high-quality
individual contributions.</p>
<p>Type 1 engineers find ways to learn computer science in depth, whether through
conventional means or by relentlessly learning throughout their careers. Type 2
engineers typically stay at the surface, learning specific tools and
technologies rather than their underlying foundations, only picking up new
skills when the winds of technical fashion change.</p>
<p>Currently, the number of people entering the industry is rapidly increasing,
while the number of CS grads is relatively static. This oversupply of Type 2
engineers is starting to reduce their employment opportunities and keep them out
of the industry‚Äôs more fulfilling work. Whether you‚Äôre striving to become a Type
1 engineer or simply looking for more job security, learning computer science is
the only reliable path.</p>
<h2 id="subject-guides">Subject guides</h2>
<h3 id="programming">Programming</h3>
<p>Most undergraduate CS programs start with an ‚Äúintroduction‚Äù to computer
programming. The best versions of these courses cater not just to novices, but
also to those who missed beneficial concepts and programming models while first
learning to code.</p>
<p>Our standard recommendation for this content is the classic <em>Structure and
Interpretation of Computer Programs</em>, which is available online for free both as
<a href="https://sarabander.github.io/sicp/html/index.xhtml" class="external-link">a book</a>, and as a set of
<a href="https://ocw.mit.edu/courses/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video_galleries/video-lectures/" class="external-link">MIT video lectures</a>.
While those lectures are great, our video suggestion is actually
<a href="https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter" class="external-link">Brian Harvey‚Äôs SICP lectures</a>
(for the 61A course at Berkeley) instead. These are more refined and better
targeted at new students than are the MIT lectures.</p>
<p>We recommend working through at least the first three chapters of SICP and doing
the exercises. For additional practice, work through a set of small programming
problems like those on <a href="http://exercism.io/" class="external-link">exercism</a>.</p>
<p>Since this guide was first published in 2016, one of the most commonly asked
questions has been whether we‚Äôd now recommend recordings of a more recent
iteration of 61A taught by John DeNero, and/or the corresponding book
<em><a href="https://composingprograms.com/" class="external-link">Composing Programs</a></em>, which is ‚Äúin the
tradition of SICP‚Äù but uses Python. We think the DeNero resources are also
great, and some students may end up preferring them, but we still suggest SICP,
Scheme, and Brian Harvey‚Äôs lectures as the first set of resources to try.</p>
<p>Why? Because SICP is unique in its ability‚Äîat least potentially‚Äîto alter your
fundamental beliefs about computers and programming. Not everybody will
experience this. Some will hate the book, others won't get past the first few
pages. But the potential reward makes it worth trying.</p>
<p>If you don't enjoy SICP, try <em>Composing Programs</em>. If that still doesn't suit,
try <em><a href="http://www.htdp.org/" class="external-link">How to Design Programs</a></em>. If none of these seem to
be rewarding your effort, perhaps that's a sign that you should focus on other
topics for some time, and revisit the discipline of programming in another year
or two.</p>
<p>Finally, a point of clarification: this guide is NOT designed for those who are
entirely new to programming. We assume that you are a competent programmer
without a background in computer science, looking to fill in some knowledge
gaps. The fact that we've included a section on "programming" is simply a
reminder that there may be more to learn. For those who've never coded before,
but who'd like to, you might prefer a guide like
<a href="https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_getting_started" class="external-link">this one</a>.</p>
<p>[<figure>
  <img src="/img/book_cover/sicp.jpg" width="" alt="Structure and Interpretation of Computer Programs" title="Structure and Interpretation of Computer Programs" />
<br />
<figcaption>Structure and Interpretation of Computer Programs</figcaption></p>
<p></figure>
](https://sarabander.github.io/sicp/html/index.xhtml)</p>
<h3 id="computer-architecture">Computer Architecture</h3>
<p>Computer Architecture‚Äîsometimes called ‚Äúcomputer systems‚Äù or ‚Äúcomputer
organization‚Äù‚Äîis an important first look at computing below the surface of
software. In our experience, it‚Äôs the most neglected area among self-taught
software engineers.</p>
<p>Our favorite introductory book is
<em><a href="http://csapp.cs.cmu.edu/3e/home.html" class="external-link">Computer Systems: A Programmer's Perspective</a></em>,
and a typical introductory computer architecture course using the book
<a href="http://csapp.cs.cmu.edu/3e/courses.html" class="external-link">would cover</a> most of chapters 1-6.</p>
<p>We love CS:APP for the practical, programmer-oriented approach. While there's
much more to computer architecture than what's covered in the book, it serves as
a great starting point for those who'd like to understand computer systems
primarily in order to write faster, more efficient and more reliable <em>software</em>.</p>
<p>For those who'd prefer both a gentler introduction to the topic and a balance of
hardware and software concerns, we suggest <em>The Elements of Computing Systems</em>,
also known as ‚ÄúNand2Tetris‚Äù. This is an ambitious book attempting to give you a
cohesive understanding of how everything in a computer works. Each chapter
involves building a small piece of the overall system, from writing elementary
logic gates in HDL, through a CPU and assembler, all the way to an application
the size of a Tetris game.</p>
<p>We recommend reading through the first six chapters of the book and completing
the associated projects. This will develop your understanding of the
relationship between the architecture of the machine and the software that runs
on it.</p>
<p>The first half of the book (and all of its projects), are available for free
from <a href="http://www.nand2tetris.org/" class="external-link">the Nand2Tetris website</a>. It‚Äôs also available
as
<a href="https://www.coursera.org/learn/build-a-computer" class="external-link">a Coursera course with accompanying videos</a>.</p>
<p>In seeking simplicity and cohesiveness, Nand2Tetris trades off depth. In
particular, two very important concepts in modern computer architectures are
pipelining and memory hierarchy, but both are mostly absent from the text.</p>
<p>Once you feel comfortable with the content of Nand2Tetris, we suggest either
returning to CS:APP, or considering Patterson and Hennessy‚Äôs
<em><a href="https://smile.amazon.com/Computer-Organization-Design-Fifth-Architecture/dp/0124077269" class="external-link">Computer Organization and Design</a></em>,
an excellent and now classic text. Not every section in the book is essential;
we suggest following Berkeley‚Äôs
<a href="http://inst.eecs.berkeley.edu/~cs61c/sp15/" class="external-link">CS61C course</a> ‚ÄúGreat Ideas in
Computer Architecture‚Äù for specific readings. The lecture notes and labs are
available online, and past lectures are
<a href="https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_" class="external-link">on the Internet Archive</a>.</p>
<p>[<figure>
  <img src="/img/book_cover/csapp.jpg" width="" alt="Computer Systems: A Programmer's Perspective" title="Computer Systems: A Programmer's Perspective" />
<br />
<figcaption>Computer Systems: A Programmer's Perspective</figcaption></p>
<p></figure>
](http://csapp.cs.cmu.edu/3e/home.html)</p>
<blockquote>
<p>Hardware is the platform</p>
</blockquote>
<p>‚Äì Mike Acton, Engine Director at Insomniac Games
(<a href="https://www.youtube.com/watch?v=rX0ItVEVjHc" class="external-link">watch his CppCon talk</a>)</p>
<h3 id="algorithms-and-data-structures">Algorithms and Data Structures</h3>
<p>We agree with decades of common wisdom that familiarity with common algorithms
and data structures is one of the most empowering aspects of a computer science
education. This is also a great place to train one‚Äôs general problem-solving
abilities, which will pay off in every other area of study.</p>
<p>There are hundreds of books available, but our favorite is
<em><a href="https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/" class="external-link">The Algorithm Design Manual</a></em>
by Steven Skiena. He clearly loves algorithmic problem solving and typically
succeeds in fostering similar enthusiasm among his students and readers. In our
opinion, the two more commonly suggested texts (CLRS and Sedgewick) tend to be a
little too proof-heavy for those learning the material primarily to help with
practical problem solving.</p>
<p>For those who prefer video lectures,
<a href="https://www3.cs.stonybrook.edu/~skiena/373/videos/" class="external-link">Skiena generously provides his online</a>.
We also really like Tim Roughgarden‚Äôs course, available
<a href="https://www.coursera.org/specializations/algorithms" class="external-link">on Coursera</a> and
<a href="http://timroughgarden.org/videos.html" class="external-link">elsewhere</a>. Whether you prefer Skiena‚Äôs
or Roughgarden‚Äôs lecture style will be a matter of personal preference. In fact,
there are dozens of good alternatives, so if you happen to find another that you
like, we encourage you to stick with it!</p>
<p>For practice, our preferred approach is for students to solve problems on
<a href="http://leetcode.com/" class="external-link">Leetcode</a>. These tend to be interesting problems with
decent accompanying solutions and discussions. They also help you test progress
against questions that are commonly used in technical interviews at the more
competitive software companies. We suggest solving around 100 random leetcode
problems as part of your studies.</p>
<p>Finally, we strongly recommend
<em><a href="https://smile.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069116407X/" class="external-link">How to Solve It</a></em>
as an excellent and unique guide to general problem solving; it‚Äôs as applicable
to computer science as it is to mathematics.</p>
<p>[<figure>
  <img src="/img/book_cover/skiena.jpg" width="" alt="The Algorithm Design Manual" title="The Algorithm Design Manual" />
<br />
<figcaption>The Algorithm Design Manual</figcaption></p>
<p></figure>
](https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/)
[<figure>
  <img src="/img/book_cover/polya.jpg" width="" alt="How to Solve It" title="How to Solve It" />
<br />
<figcaption>How to Solve It</figcaption></p>
<p></figure>
](https://smile.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069116407X/)</p>
<blockquote>
<p>I have only one method that I recommend extensively‚Äîit‚Äôs called think before
you write.</p>
</blockquote>
<p>‚Äî Richard Hamming</p>
<h3 id="mathematics-for-computer-science">Mathematics for Computer Science</h3>
<p>In some ways, computer science is an overgrown branch of applied mathematics.
While many software engineers try‚Äîand to varying degrees succeed‚Äîat ignoring
this, we encourage you to embrace it with direct study. Doing so successfully
will give you an enormous competitive advantage over those who don‚Äôt.</p>
<p>The most relevant area of math for CS is broadly called ‚Äúdiscrete mathematics‚Äù,
where ‚Äúdiscrete‚Äù is the opposite of ‚Äúcontinuous‚Äù and is loosely a collection of
interesting applied math topics outside of calculus. Given the vague definition,
it‚Äôs not meaningful to try to cover the entire breadth of ‚Äúdiscrete
mathematics‚Äù. A more realistic goal is to build a working understanding of
logic, combinatorics and probability, set theory, graph theory, and a little of
the number theory informing cryptography. Linear algebra is an additional
worthwhile area of study, given its importance in computer graphics and machine
learning.</p>
<p>Our suggested starting point for discrete mathematics is the set of
<a href="https://cims.nyu.edu/~regev/teaching/discrete_math_fall_2005/dmbook.pdf" class="external-link">lecture notes by L√°szl√≥ Lov√°sz</a>.
Professor Lov√°sz did a good job of making the content approachable and
intuitive, so this serves as a better starting point than more formal texts.</p>
<p>For a more advanced treatment, we suggest
<em><a href="https://courses.csail.mit.edu/6.042/spring17/mcs.pdf" class="external-link">Mathematics for Computer Science</a></em>,
the book-length lecture notes for the MIT course of the same name. That course‚Äôs
video lectures are also
<a href="https://ocw.mit.edu/courses/6-042j-mathematics-for-computer-science-fall-2010/video_galleries/video-lectures/" class="external-link">freely available</a>,
and are our recommended video lectures for discrete math.</p>
<p>For linear algebra, we suggest starting with the
<a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab" class="external-link">Essence of linear algebra</a>
video series, followed by Gilbert Strang‚Äôs
<a href="https://www.amazon.com/Introduction-Linear-Algebra-Gilbert-Strang/dp/0980232775/" class="external-link">book</a>
and
<a href="https://ocw.mit.edu/courses/18-06sc-linear-algebra-fall-2011/" class="external-link">video lectures</a>.</p>
<blockquote>
<p>If people do not believe that mathematics is simple, it is only because they
do not realize how complicated life is.</p>
</blockquote>
<p>‚Äî John von Neumann</p>
<h3 id="operating-systems">Operating Systems</h3>
<p><em><a href="https://www.amazon.com/dp/1118063333/" class="external-link">Operating System Concepts</a></em> (the
‚ÄúDinosaur book‚Äù) and
<em><a href="https://www.amazon.com/dp/013359162X/" class="external-link">Modern Operating Systems</a></em> are the
‚Äúclassic‚Äù books on operating systems. Both have attracted criticism for their
lack of clarity and general student unfriendliness.</p>
<p><em>Operating Systems: Three Easy Pieces</em> is a good alternative that‚Äôs
<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" class="external-link">freely available online</a>. We
particularly like the structure and readability of the book, and feel that the
exercises are worthwhile.</p>
<p>After OSTEP, we encourage you to explore the design decisions of specific
operating systems, through ‚Äú{OS name} Internals‚Äù style books such as
<em><a href="https://www.amazon.com/Lions-Commentary-Unix-John/dp/1573980137/" class="external-link">Lion's commentary on Unix</a></em>,
<em><a href="https://www.amazon.com/Design-Implementation-FreeBSD-Operating-System/dp/0321968972/" class="external-link">The Design and Implementation of the FreeBSD Operating System</a></em>,
and
<em><a href="https://www.amazon.com/Mac-OS-Internals-Systems-Approach/dp/0321278542/" class="external-link">Mac OS X Internals</a></em>.
For Linux, we suggest Robert Love's fantastic
<a href="https://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468" class="external-link">Linux Kernel Development</a>.</p>
<p>A great way to consolidate your understanding of operating systems is to read
the code of a small kernel and add features. One choice is
<a href="https://pdos.csail.mit.edu/6.828/2016/xv6.html" class="external-link">xv6</a>, a port of Unix V6 to ANSI
C and x86, maintained for a course at MIT. OSTEP has an appendix of potential
<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/lab-projects-xv6.pdf" class="external-link">xv6 labs</a> full of
great ideas for potential projects.</p>
<p>[<figure>
  <img src="/img/book_cover/ostep.jpeg" width="" alt="Operating Systems: Three Easy Pieces" title="Operating Systems: Three Easy Pieces" />
<br />
<figcaption>Operating Systems: Three Easy Pieces</figcaption></p>
<p></figure>
](http://pages.cs.wisc.edu/~remzi/OSTEP/)</p>
<h3 id="computer-networking">Computer Networking</h3>
<p>Given that so much of software engineering is on web servers and clients, one of
the most immediately valuable areas of computer science is computer networking.
Our self-taught students who methodically study networking find that they
finally understand terms, concepts and protocols they‚Äôd been surrounded by for
years.</p>
<p>Our favorite book on the topic is
<em><a href="https://smile.amazon.com/Computer-Networking-Top-Down-Approach-7th/dp/0133594149/" class="external-link">Computer Networking: A Top-Down Approach</a></em>.
The small projects and exercises in the book are well worth doing, and we
particularly like the ‚ÄúWireshark labs‚Äù, which they have
<a href="http://www-net.cs.umass.edu/wireshark-labs/" class="external-link">generously provided online</a>.</p>
<p>For those who prefer video lectures, we suggest Stanford‚Äôs
<a href="https://www.youtube.com/playlist?list=PLoCMsyE1cvdWKsLVyf6cPwCLDIZnOj0NS" class="external-link"><em>Introduction to Computer Networking course</em></a>
previously available via Stanford's MOOC platform Lagunita, but sadly now only
available as unofficial playlists on Youtube.</p>
<blockquote>
<p>You can‚Äôt gaze in the crystal ball and see the future. What the Internet is
going to be in the future is what society makes it.</p>
</blockquote>
<p>‚Äî Bob Kahn</p>
<p>[<figure>
  <img src="/img/book_cover/top-down.jpg" width="" alt="Computer Networking: A Top-Down Approach" title="Computer Networking: A Top-Down Approach" />
<br />
<figcaption>Computer Networking: A Top-Down Approach</figcaption></p>
<p></figure>
](https://smile.amazon.com/Computer-Networking-Top-Down-Approach-7th/dp/0133594149/)</p>
<h3 id="databases">Databases</h3>
<p>It takes more work to self-learn about database systems than it does with most
other topics. It‚Äôs a relatively new (i.e. post 1970s) field of study with strong
commercial incentives for ideas to stay behind closed doors. Additionally, many
potentially excellent textbook authors have preferred to join or start companies
instead.</p>
<p>Given the circumstances, we encourage self-learners to generally avoid textbooks
and start with
<a href="https://www.youtube.com/user/CS186Berkeley/videos" class="external-link">recordings of CS 186</a>, Joe
Hellerstein‚Äôs databases course at Berkeley, and to progress to reading papers
after.</p>
<p>One paper particularly worth mentioning for new students is
‚Äú<a href="http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf" class="external-link">Architecture of a Database System</a>‚Äù,
which uniquely provides a high-level view of how relational database management
systems (RDBMS) work. This will serve as a useful skeleton for further study.</p>
<p><em>Readings in Database Systems</em>, better known as
<a href="http://www.redbook.io/" class="external-link">the databases ‚ÄúRed Book‚Äù</a>, is a collection of papers
compiled and edited by Peter Bailis, Joe Hellerstein and Michael Stonebraker.
For those who have progressed beyond the level of the CS 186 content, the Red
Book should be your next stop.</p>
<p>If you're adamant about using an introductory textbook, we suggest
<em><a href="https://smile.amazon.com/Database-Management-Systems-Raghu-Ramakrishnan/dp/0072465638/" class="external-link">Database Management Systems</a></em>
by Ramakrishnan and Gehrke. For more advanced students, Jim Gray‚Äôs classic
<em><a href="https://www.amazon.com/Transaction-Processing-Concepts-Techniques-Management/dp/1558601902" class="external-link">Transaction Processing: Concepts and Techniques</a></em>
is worthwhile, but we don‚Äôt encourage using this as a first resource.</p>
<p>Finally, data modeling is a neglected and poorly taught aspect of working with
databases. Our suggested book on the topic is
<em><a href="https://www.amazon.com/Data-Reality-Perspective-Perceiving-Information/dp/1935504215" class="external-link">Data and Reality: A Timeless Perspective on Perceiving and Managing Information in Our Imprecise World</a></em>.</p>
<p>[<figure>
  <img src="/img/book_cover/redbook.jpg" width="" alt="Readings in Database Systems" title="Readings in Database Systems" />
<br />
<figcaption>Readings in Database Systems</figcaption></p>
<p></figure>
](http://www.redbook.io/)
[<figure>
  <img src="/img/book_cover/data-reality.jpg" width="" alt="Data and Reality" title="Data and Reality" />
<br />
<figcaption>Data and Reality</figcaption></p>
<p></figure>
](https://www.amazon.com/Data-Reality-Perspective-Perceiving-Information/dp/1935504215)</p>
<h3 id="languages-and-compilers">Languages and Compilers</h3>
<p>Most programmers learn languages, whereas most computer scientists learn <em>about</em>
languages. This gives the computer scientist a distinct advantage over the
programmer, even in the domain of programming! Their knowledge generalizes; they
are able to understand the operation of a new language more deeply and quickly
than those who have merely learned specific languages.</p>
<p>Our suggested introductory text is the excellent
<em><a href="https://craftinginterpreters.com/contents.html" class="external-link">Crafting Interpreters</a></em> by Bob
Nystrom, available for free online. It's well organized, highly entertaining,
and well suited to those whose primary goal is simply to better understand their
languages and language tools. We suggest taking the time to work through the
whole thing, attempting whichever of the "challenges" sustain your interest.</p>
<p>A more traditional recommendation is
<em><a href="https://smile.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811" class="external-link">Compilers: Principles, Techniques &amp; Tools</a></em>,
commonly called ‚Äúthe Dragon Book‚Äù. Unfortunately, it‚Äôs not designed for
self-study, but rather for instructors to pick out 1-2 semesters worth of topics
for their courses.</p>
<p>If you elect to use the Dragon Book, it‚Äôs almost essential that you cherry-pick
the topics, ideally with the help of a mentor. In fact, our suggested way to
utilize the Dragon Book, if you so choose, is as a supplementary reference for a
video lecture series. Our recommended one is
<a href="https://www.edx.org/course/compilers" class="external-link">Alex Aiken‚Äôs, on edX</a>.</p>
<p>[<figure>
  <img src="/img/book_cover/dragon.jpg" width="" alt="Compilers: Principles, Techniques & Tools" title="Compilers: Principles, Techniques & Tools" />
<br />
<figcaption>Compilers: Principles, Techniques & Tools</figcaption></p>
<p></figure>
](https://smile.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811)</p>
<blockquote>
<p>Don‚Äôt be a boilerplate programmer. Instead, build tools for users and other
programmers. Take historical note of textile and steel industries: do you want
to build machines and tools, or do you want to operate those machines?</p>
</blockquote>
<p>‚Äî Ras Bodik at the start of his compilers course</p>
<h3 id="distributed-systems">Distributed Systems</h3>
<p>As computers have increased in number, they have also <em>spread</em>. Whereas
businesses would previously purchase larger and larger mainframes, it‚Äôs typical
now for even very small applications to run across multiple machines.
Distributed systems is the study of how to reason about the trade-offs involved
in doing so.</p>
<p>Our suggested book for self-study is Martin Kleppmann's
<em><a href="https://smile.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable-ebook/dp/B06XPJML5D/" class="external-link">Designing Data-Intensive Applications</a></em>.
Far better than a traditional textbook, DDIA is a highly readable book designed
for practitioners, which somehow avoids sacrificing depth or rigor.</p>
<p>For those seeking a more traditional text, or who would prefer one that‚Äôs
available for free online, we suggest Maarten van Steen and Andrew Tanenbaum‚Äôs
<em><a href="https://www.distributed-systems.net/index.php/books/ds3/" class="external-link">Distributed Systems, 3rd Edition</a></em>.</p>
<p>For those who prefer video, an excellent course with videos available online is
<a href="https://www.youtube.com/watch?v=cQP8WApzIQQ&amp;list=PLrw6a1wE39_tb2fErI4-WkMbsvGQk9_UB" class="external-link">MIT‚Äôs 6.824</a>,
a graduate course taught by Robert Morris with readings available
<a href="https://pdos.csail.mit.edu/6.824/schedule.html" class="external-link">here</a>.</p>
<p>No matter the choice of textbook or other secondary resources, study of
distributed systems absolutely mandates reading papers. A good list is
<a href="http://dsrg.pdos.csail.mit.edu/papers/" class="external-link">here</a>, and we would highly encourage
attending your local <a href="http://paperswelove.org/" class="external-link">Papers We Love</a> chapter.</p>
<p>[<figure>
  <img src="/img/book_cover/ddia.jpg" width="" alt="Designing Data-Intensive Applications" title="Designing Data-Intensive Applications" />
<br />
<figcaption>Designing Data-Intensive Applications</figcaption></p>
<p></figure>
](https://smile.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable-ebook/dp/B06XPJML5D/)</p>
<h2 id="frequently-asked-questions">Frequently asked questions</h2>
<h4 id="who-is-the-target-audience-for-this-guide">Who is the target audience for this guide?</h4>
<p>We have in mind that you are a self-taught software engineer, bootcamp grad or
precocious high school student, or a college student looking to supplement your
formal education with some self-study. The question of when to embark upon this
journey is an entirely personal one, but most people tend to benefit from having
some professional experience before diving too deep into CS theory. For
instance, we notice that students <em>love</em> learning about database systems if they
have already worked with databases professionally, or about computer networking
if they‚Äôve worked on a web project or two.</p>
<h4 id="what-about-ai-graphics-pet-topic-x">What about AI/graphics/pet-topic-X?</h4>
<p>We‚Äôve tried to limit our list to computer science topics that we feel <em>every
practicing software engineer</em> should know, irrespective of specialty or
industry, but with a focus on systems. In our experience, these will be the
highest ROI topics for the overwhelming majority of self-taught engineers and
bootcamp grads, and provide a solid foundation for further study. Subsequently,
you‚Äôll be in a much better position to pick up textbooks or papers and learn the
core concepts without much guidance. Here are our suggested starting points for
a couple of common ‚Äúelectives‚Äù:</p>
<ul>
<li>
<p>For artificial intelligence: do
  <a href="http://ai.berkeley.edu/" class="external-link">Berkeley‚Äôs intro to AI course</a> by watching the
  videos and completing the excellent Pacman projects. As a textbook, use
  Russell and Norvig‚Äôs <em>Artificial Intelligence: A Modern Approach</em>.</p>
</li>
<li>
<p>For machine learning: do Andrew Ng‚Äôs Coursera course. Be patient, and make
  sure you understand the fundamentals before racing off to shiny new topics
  like deep learning.</p>
</li>
<li>
<p>For computer graphics: work through
  <a href="http://inst.eecs.berkeley.edu/~cs184/fa12/onlinelectures.html" class="external-link">Berkeley‚Äôs CS 184</a>
  material, and use
  <a href="https://www.amazon.com/Computer-Graphics-Principles-Practice-3rd/dp/0321399528" class="external-link">Computer Graphics: Principles and Practice</a>
  as a textbook.</p>
</li>
</ul>
<h4 id="how-strict-is-the-suggested-sequencing">How strict is the suggested sequencing?</h4>
<p>Realistically, all of these subjects have a significant amount of overlap, and
refer to one another cyclically. Take for instance the relationship between
discrete math and algorithms: learning math first would help you analyze and
understand your algorithms in greater depth, but learning algorithms first would
provide greater motivation and context for discrete math. Ideally, you‚Äôd revisit
both of these topics many times throughout your career.</p>
<p>As such, our suggested sequencing is mostly there to help you <em>just get
started</em>‚Ä¶ if you have a compelling reason to prefer a different sequence, then
go for it. The most significant ‚Äúpre-requisites‚Äù in our opinion are: computer
architecture before operating systems or databases, and networking and operating
systems before distributed systems.</p>
<h4 id="how-does-this-compare-to-open-source-society-or-freecodecamp-curricula">How does this compare to Open Source Society or freeCodeCamp curricula?</h4>
<p>When this guide was first written in 2016, the
<a href="https://github.com/open-source-society/computer-science" class="external-link">OSS guide</a> had too
many subjects, suggested inferior resources for many of them, and provided no
rationale or guidance around why or what aspects of particular courses are
valuable. We strove to limit our list of courses to those which you <em>really
should know</em> as a software engineer, irrespective of your specialty, and to help
you understand why each course is included. In the subsequent years, the OSS
guide has improved, but we still think that this one provides a clearer, more
cohesive path.</p>
<p>freeCodeCamp is focused mostly on programming, not computer science. For why you
might want to learn computer science, see
<a href="https://teachyourselfcs.com/#why" class="external-link">above</a>. If you are new to programming, we
suggest prioritizing that, and returning to this guide in a year or two.</p>
<h4 id="what-about-language-x">What about language X?</h4>
<p>Learning a particular programming language is on a totally different plane to
learning about an area of computer science ‚Äî learning a language is much
<em>easier</em> and much <em>less valuable</em>. If you already know a couple of languages, we
strongly suggest simply following our guide and fitting language acquisition in
the gaps, or leaving it for afterwards. If you‚Äôve learned programming well (such
as through <em>Structure and Interpretation of Computer Programs</em>), and especially
if you have learned compilers, it should take you little more than a weekend to
learn the essentials of a new language, after which you can learn about the
libraries/tooling/ecosystem on the job.</p>
<h4 id="what-about-trendy-technology-x">What about trendy technology X?</h4>
<p>No single technology is important enough that learning to use it should be a
core part of your education. On the other hand, it‚Äôs great that you‚Äôre excited
to learn about that thing. The trick is to work backwards from the particular
technology to the underlying field or concept, and learn that in depth before
seeing how your trendy technology fits into the bigger picture.</p>
<h4 id="why-are-you-still-recommending-sicp">Why are you still recommending SICP?</h4>
<p>Look, just try it. Some people find SICP mind blowing, a characteristic shared
by very few other books. If you don't like it, you can always try something else
and perhaps return to SICP later.</p>
<h4 id="why-are-you-still-recommending-the-dragon-book">Why are you still recommending the Dragon book?</h4>
<p>The Dragon book is still the most complete single resource for compilers. It
gets a bad rap, typically for overemphasizing certain topics that are less
fashionable to cover in detail these days, such as parsing. The thing is, the
book was never intended to be studied cover to cover, only to provide enough
material for an instructor to put together a course. Similarly, a self-learner
can choose their own adventure through the book, or better yet follow the
suggestions that lecturers of public courses have made in their course outlines.</p>
<h4 id="how-can-i-get-textbooks-cheaply">How can I get textbooks cheaply?</h4>
<p>Many of the textbooks we suggest are freely available online, thanks to the
generosity of their authors. For those that aren‚Äôt, we suggest buying used
copies of older editions. As a general rule, if there has been more than a
couple of editions of a textbook, it‚Äôs quite likely that an older edition is
perfectly adequate. It‚Äôs certainly unlikely that the newest version is 10x
better than an older one, even if that‚Äôs what the price difference is!</p>
<h4 id="who-made-this">Who made this?</h4>
<p>This guide was originally written by <a href="https://twitter.com/oznova_" class="external-link">Oz Nova</a> and
<a href="https://twitter.com/quackingduck" class="external-link">Myles Byrne</a>, with 2020 updates by Oz. It is
based on our experience teaching foundational computer science to over 1000
mostly self-taught engineers and bootcamp grads in small group settings in San
Francisco and live online. Thank you to all of our students for your continued
feedback on self-teaching resources.</p>
<p>We're very confident that you could teach yourself everything above, given
enough time and motivation. But if you'd prefer an intensive, structured,
instructor-led program, you might be interested in our
<a href="https://bradfieldcs.com/csi/" class="external-link">Computer Science Intensive</a>. We
<a href="https://ozwrites.com/masters/" class="external-link">DON'T</a> suggest pursuing a master's degree.</p></div>
<div class="note-footer">
<div class="backlinks">
<h2>Backlinks</h2>
<ul>
	<li><a class="backlink" href="/how do I study computer science.html">how do i study computer science</a></li>
</ul>
</div>

<div class="tags">
<h2>Tags</h2>
<ul>
	<li><a class="backlink" href="/obs.html/tags/inbox/index.html">inbox</a></li>
	<li><a class="backlink" href="/obs.html/tags/permanent/index.html">permanent</a></li>
</ul>
</div>

</div>
<div class="graph requires_js ">
    <div id="A36882681149952483760806575752563538837{level}" class="graph_div"></div>
    
    <div class="graph-button-row" style="display:flex;">
        <button class="graph_button graph_show_button" id="B36882681149952483760806575752563538837{level}" level="{level}" note_temp_id="36882681149952483760806575752563538837" onclick="window.ObsHtmlGraph.run(this, '36882681149952483760806575752563538837', 'tech yourself computer science');">
            Show Graph
        </button>
        <button class="graph_button graph_type_button" id="C36882681149952483760806575752563538837{level}" style="flex:1" onclick="window.ObsHtmlGraph.switch_graph_type(this);">
            2D
        </button>
    </div>
</div>

<script type="module">
    if (window.ObsHtmlGraph == undefined){
        import('/obs.html/static/graph.js').then((Module) => {
            window.ObsHtmlGraph = Module;
            window.ObsHtmlGraph.arm_page(document.getElementById('page_holder'))
        })
    }
</script>




                <!-- end content -->
            </div>
        </div>
    </div>

    <script>
        function handle_toggle_side_bar(e) {
            let header;
            let pane;
            let target = e.target;

            // switch out the navbar button click for a header click
            if (target.id == "left_pane_toggle_nav") {
                target = document.getElementById("left_pane_fold_header");
            } else if (target.id == "right_pane_toggle_nav") {
                target = document.getElementById("right_pane_fold_header");
            }

            // get header and pane
            if (target.classList.contains("fold_header")) {
                header = target;
                pane = target.parentElement;
            } else {
                pane = target;
                header = target.getElementsByClassName("fold_header")[0];
            }
            toggle_side_bar(pane, header, true);
            e.stopPropagation();
        }
        function handle_toggle_side_bar_button(e) {
            document.getElementById("menu_toggle_button").click();
            handle_toggle_side_bar(e);
        }

        function toggle_side_bar(pane, header, save) {
            let active = pane.classList.contains("active");
            if (active) {
                disable_side_bar(pane, header, save);
            } else {
                enable_side_bar(pane, header, save);
            }
        }
        function enable_side_bar(pane, header, save) {
            pane.classList.add("active");
            pane.removeEventListener("click", handle_toggle_side_bar);
            header.addEventListener("click", handle_toggle_side_bar);
            set_correct_header_symbol(header);
            if (save) {
                save_panel_folding_state(header, true);
            }
        }
        function disable_side_bar(pane, header, save) {
            pane.classList.remove("active");
            pane.addEventListener("click", handle_toggle_side_bar);
            header.removeEventListener("click", handle_toggle_side_bar);
            set_correct_header_symbol(header);
            if (save) {
                save_panel_folding_state(header, false);
            }
        }
        function set_correct_header_symbol(header) {
            let pane = header.parentElement;
            let symbol = [
                [">", "<"],
                ["<", ">"],
            ];
            symbol =
                symbol[Number(header.classList.contains("right_pane_fold_header"))][
                Number(pane.classList.contains("active"))
                ];
            console.log(symbol);
            header.innerHTML = symbol;
            return header;
        }
        function panel_folding_get_panel_name(header) {
            return ["left", "right"][
                Number(header.classList.contains("right_pane_fold_header"))
            ];
        }
        function save_panel_folding_state(header, active) {
            ls_set(
                "pane_folding_state_" + panel_folding_get_panel_name(header),
                Number(active)
            );
        }
        function load_panel_folding_state(panel_name) {
            val = ls_get("pane_folding_state_" + panel_name);
            if (!val) {
                return {exists: false, value: null};
            }
            return {exists: true, value: Boolean(Number(val))};
        }
        function set_pane_folding_start(left_header, right_header) {
            // small screen = closed
            let right_pane_enabled = true;
            let left_pane_enabled = true;
            let w = window.visualViewport.width;
            if (w < 1000) {
                left_pane_enabled = false;
            }
            if (w < 800) {
                right_pane_enabled = false;
            }

            // get saved values if present
            let rval = load_panel_folding_state("right");
            if (rval["exists"]) {
                right_pane_enabled = rval["value"];
            }
            let lval = load_panel_folding_state("left");
            if (lval["exists"]) {
                left_pane_enabled = lval["value"];
            }

            // default = enabled, so we only need to disable
            if (!left_pane_enabled) {
                disable_side_bar(
                    document.getElementById("left_pane"),
                    document.getElementById("left_pane_fold_header")
                );
            }
            if (!right_pane_enabled) {
                disable_side_bar(
                    document.getElementById("right_pane"),
                    document.getElementById("right_pane_fold_header")
                );
            }
        }

        function init_pane_folding(header) {
            set_correct_header_symbol(header);
            header.addEventListener("click", handle_toggle_side_bar);
        }

        set_pane_folding_start();
        init_pane_folding(document.getElementById("left_pane_fold_header"));
        init_pane_folding(document.getElementById("right_pane_fold_header"));

        document
            .getElementById("left_pane_toggle_nav")
            .addEventListener("click", handle_toggle_side_bar_button);
        document
            .getElementById("right_pane_toggle_nav")
            .addEventListener("click", handle_toggle_side_bar_button);
    </script>

    <script src="/obs.html/static/load_dirtree_footer.js" type="text/javascript"></script>
 

</body>

</html>
