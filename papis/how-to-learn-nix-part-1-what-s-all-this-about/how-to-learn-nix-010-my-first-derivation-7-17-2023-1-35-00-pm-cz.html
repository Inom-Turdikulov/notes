<!DOCTYPE html> <html lang=en style><!--
 Page saved with SingleFile 
 url: https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/ 
 saved date: Mon Jul 17 2023 13:35:00 GMT+0600 (Kyrgyzstan Time)
--><meta charset=utf-8>
<meta name=viewport content="initial-scale=1,maximum-scale=1">
<title>How to Learn Nix, Part 10: My first derivation</title>
<link rel=canonical href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/>
<style>:root{--box-radius:6px;--outer-box-radius:10px}:root{--content-bg:#fff;--gutter-bg:#eeeef3;--text-fg:#4d4d4c;--table-border-color:#ccc;--separator-color:#6d6d6c;--link:#07c;--link-visited:#751a9a;--blockquote-accent:var(--link);--footnote-accent:#ffd2a3;--subscribe-button-bg:#44e66c;--subscribe-button-fg:#11391b;--media-controls-on:#34b553;--media-controls-contrast:#fff;--inline-code-bg:#f3f3fa;--code-block-bg:#f3f3fa;--aside-bg:#f3f3fa;--aside-warning-bg:#fff5d1;--aside-warning-fg:#ac3233;--palette-red:#c82829;--palette-green:#718c00;--palette-yellow:#eab700;--palette-orange:#f5871f;--palette-blue:#4271ae;--palette-purple:#8959a8;--palette-teal:#3e999f;--palette-white:#fefefe;--palette-black:#000;--palette-text:var(--text-fg);--palette-dim:#8e908c;--highlight-bg:var(--palette-yellow);--highlight-fg:var(--text-fg)}#dmt::before{content:"🌖"}#dmt:hover::before{content:"🌗"}@media (prefers-color-scheme:dark){:root:not(.light-theme){--content-bg:#313233;--gutter-bg:#1d1f21;--text-fg:#d8d4cf;--table-border-color:#ccc;--separator-color:#6d6d6c;--link:rgb(82,183,255);--link-visited:rgb(193,104,229);--blockquote-accent:var(--link);--footnote-accent:#a8612f;--subscribe-button-bg:#44e66c;--subscribe-button-fg:#11391b;--media-controls-on:#44e66c;--media-controls-contrast:#11391b;--inline-code-bg:#3c4044;--code-block-bg:#1d1f21;--aside-bg:#3c4044;--aside-warning-bg:#fff5d1;--aside-warning-fg:var(--palette-red);--palette-red:#cc6666;--palette-green:#b5bd68;--palette-yellow:#f0c674;--palette-orange:#de935f;--palette-blue:#81a2be;--palette-purple:#b294bb;--palette-teal:#8abeb7;--palette-white:#fefefe;--palette-black:#000;--palette-text:var(--text-fg);--palette-dim:#969896;--highlight-bg:var(--palette-yellow);--highlight-fg:var(--palette-black)}:root:not(.light-theme) #dmt::before{content:"🌒"}:root:not(.light-theme) #dmt:hover::before{content:"🌓"}}#dmt{width:30px;text-align:right;padding-right:4px;position:absolute;top:0;bottom:0;right:0;border:none;background-color:inherit;cursor:pointer}*{margin:0;padding:0;font:inherit;box-sizing:border-box}html{background-color:var(--gutter-bg);color:var(--text-fg)}body{font-family:system-ui,sans-serif;font-size:12pt;line-height:1.8;word-wrap:break-word}body:not(.content-page) main>aside{padding:0 var(--content-padding)}body.content-page main,body:not(.content-page) article{background-color:var(--content-bg);border-radius:var(--outer-box-radius);padding:var(--content-padding)}pre{word-wrap:normal}em,i{font-style:italic}h1>a:only-child,h2>a:only-child{display:block}main .subsection-header+.post-list{margin-top:0}strong{font-weight:700}ol,ul{padding-left:3ch}hr{border-style:solid;border-width:1.5px 0 0;border-radius:1px;border-color:var(--separator-color)}:not(pre)>code{white-space:pre;background-color:var(--inline-code-bg)}li{padding-left:0}blockquote{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:"";content:none}a,a:active,a:visited{text-decoration:none}a:hover{text-decoration:underline}blockquote{padding:0 0 0 var(--content-padding);border-left:solid 2px var(--blockquote-accent)}aside{--content-padding:0.5em;padding:.5em;border-radius:var(--box-radius);background-color:var(--aside-bg)}a,a:active,header a:visited,footer a:visited,h1 a:visited{color:var(--link)}a:visited{color:var(--link-visited)}h1{font-size:130%}main *+p,main *+pre,main *+aside,main *+article,main *+blockquote,main *+div,main *+ul,main *+ol,main *+hr,main *+h1{margin-top:1em}main .post-header *+h1{margin-top:0}code{font-family:Menlo,monospace;padding:0 3px;border-radius:2px}pre{background-color:var(--code-block-bg);font-size:11pt;padding:calc(.75*var(--content-padding)) var(--content-padding);line-height:1.3;border-radius:var(--box-radius);overflow-x:scroll;-webkit-overflow-scrolling:touch}pre code{padding:0;border-radius:0;display:inline-block;background-color:initial}p+p{margin-top:1em}body{margin:0 auto;--content-padding:10px;max-width:768px;-webkit-text-size-adjust:100%;position:relative}header{position:relative}header>*{height:48px;line-height:48px}.promo,.promo:visited,.promo:active{display:block;text-align:center;background-color:var(--link);color:var(--code-block-bg);border-radius:0 0 var(--outer-box-radius) var(--outer-box-radius)}header .site-title{font-size:130%}header nav{position:absolute;right:30px;top:0}@media all and (max-width:400px){:root{--outer-box-radius:0}header{text-align:center}header nav{position:static}:not(pre)>code{white-space:pre-wrap}body{--content-padding:10px}#dmt{padding:0;text-align:center;width:40px}}header ul{padding:0}header li{list-style:none;display:inline-block}header a{display:block;height:100%}header li+li{margin-left:1em}footer{padding:2em 0;font-size:.85em;text-align:center}article h1.post-title{font-size:200%}article .post-title a{display:block}article .meta{font-size:90%;font-style:italic}.post-header h1{line-height:1.2em;margin-bottom:.5em}.post-footer{text-align:center}.post-footer a{display:block}ol.post-list{list-style-position:inside;padding:0}.series-rider .series-name{font-style:italic}.highlight{color:var(--palette-text)}.highlight .err{color:var(--palette-red)}.highlight .k{color:var(--palette-purple)}.highlight .n{color:var(--palette-text)}.highlight .o{color:var(--palette-teal)}.highlight .p{color:var(--palette-text)}.highlight .c1{color:var(--palette-dim)}.highlight .nb{color:var(--palette-text)}.highlight .nv{color:var(--palette-red)}.highlight .sd{color:var(--palette-dim)}.highlight .s2{color:var(--palette-green)}.highlight .sr{color:var(--palette-green)}</style>
<meta property=og:title content="How to Learn Nix, Part 10: My first derivation">
<meta property=og:type content=website>
<meta property=og:url content=https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/>
<meta name=description content="We got to Part IV! We have learned everything we need to know about Package Management and now get to learn about Writing Nix Expressions.
I have to point out that this “part” basically starts out with a link to a whole other manual. My goodness. I don’t know if I can type up every thought that goes through my head as I read two manuals. I’ve gotta sleep at some point.">
<meta property=og:description content="We got to Part IV! We have learned everything we need to know about Package Management and now get to learn about Writing Nix Expressions.
I have to point out that this “part” basically starts out with a link to a whole other manual. My goodness. I don’t know if I can type up every thought that goes through my head as I read two manuals. I’ve gotta sleep at some point.">
<meta property=og:image content=https://ianthehenry.com/checkerboard.png>
<meta name=twitter:creator content=@ianthehenry>
<meta name=twitter:card content=summary>
<link type=image/x-icon rel="shortcut icon" href="data:image/vnd.microsoft.icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAHH1uIDShg/xEsZv8GFk3/CSJb/wgZT/8IGU//CBlP/wkiW/8HGE7/CBlP/wkiW/8HIFX/BxhO/wcgVf8OK2t7JDhz/wcfW/8NNn7/CSpq/wkjYf8MJGP/DCJg/w02ef9SqdX/TKHJ/1my2f9Moc3/UqzV/1Cr1v9Pocf/Ditr/xk2cf8KJGL/CjR8/wwva/8RK2r/Cido/w8qa/8LLW//TqjT/1Gnz/9bsNf/Sp/K/1Wt2f9Wrtj/UKjQ/w8xc/8gPHj/Di5w/xk4ef8TL27/Dy5u/xU3fv8QLGv/Ditr/1qy3f9dttv/Yrje/0ecx/9Knsz/U6fQ/1m13f8YN3n/JjZx/wszdv8YOXz/Eilm/xc3e/8dSZT/GDJz/xk/hv9hu+P/WbHZ/1mv1v9Kn8z/WLHd/1212v9ds9n/Eipr/xcqYv8SOX3/GzRz/xQrZ/8aM3D/HEuU/xc0df8fPYD/Yrre/1603P9dt9z/VKvY/1iz4v9etNr/Y73m/xk5fP8cMm3/JEWK/xc0dP8eO3v/Hjd4/ydRnP8WM3P/Gjd3/2bA5/9dtd//Ybng/2K95v9ct+P/Ybnf/2K95/8oS5L/GChg/xxBh/8lSIz/GC5s/yM5ev8hRoz/HTp7/yE6e/9Zsdz/YLzn/2jF7v9ryfL/YLzn/1qu1f9htdz/GDyD/y0/ev9qx/X/acDn/1235v9euun/Yb3r/1665v9owu7/GUOL/yhGh/8nUJL/MkmI/yBFiP8jOHb/MVag/yM+gv8VMGv/acXx/27G7/9szv3/bMb1/2zD6/9vy/X/edf5/yBHjv8yS47/JEuO/zVLiv8nS5D/LkOB/yRXpP8lQoT/H0WI/3fS+P910Pf/b8/8/2bB7/991Pn/eNb+/3nT+P8pS5L/O1GS/ytUnP86UJH/NF2k/zNLjP8sXKv/JkCB/x4+ff+B2/3/etT9/4He//922f//fNf//3TT//991/7/NU6N/zZSkP86Zav/PlWR/zFepv88ZKb/MF2n/yQ/gf8bNXH/fd3//3/b//+K6P//ft///3vV//993f//gdz//0hWlf9FZKX/RmOj/0JXlv9IeMP/QXKz/0Jsuf8eO3z/Hjt2/3vd//+C3v//ju3//3zg//+H4v//guL//4nj//9HXp3/UGur/ztgqf9JYqP/S3G4/05ur/9EbLT/Hjt7/zNJhf+G4///heT//4rq//+E5///iOT//4jr//+G4///UXO0/09iov9EX6H/SWWn/1V5wP9Kaa7/RGSp/ydLj/8NKGCfDShg/x8+d/8RLGb/CBlP/wYWTf8GFEj/CBNH/wooZP8JIlv/CCJd/woWSf8HGE7/ByBV/wwgU/8fO3mfAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
<body class=content-page>
<a class=promo href=https://janet.guide/ target=_blank><i>psst, hey kid, wanna read a weird programming book</i></a>
<header>
<a class=site-title href=https://ianthehenry.com/>Ian Henry</a>
<nav>
<ul><li><a href=https://ianthehenry.com/about/>About</a><li><a href=https://ianthehenry.com/posts/>Blog</a><li><a href=https://ianthehenry.com/stuff/>Stuff</a></ul>
</nav>
<button id=dmt title="Toggle dark mode"></button>
</header>
<main>
<aside class=series-rider>
<p>This post is part of the series <a class=series-name href=https://ianthehenry.com/posts/how-to-learn-nix/>How to Learn Nix</a>, a rambling diary in which I work my way through the Nix manual in excrutiating detail.</p>
</aside>
<article class=post>
<div class=post-header>
<time class=meta datetime=2021-03-08>March 8, 2021</time>
<h1 class=post-title>
<a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/>How to Learn Nix, Part&nbsp;10:<br>My first derivation</a></h1>
</div>
<div class=post-content><p>We got to Part IV! We have learned everything we need to know about <em>Package Management</em> and now get to learn about <em>Writing Nix Expressions</em>.</p>
<p>I have to point out that this “part” basically starts out with a link to a <a href=https://nixos.org/manual/nixpkgs/stable/><em>whole other manual</em></a>. My goodness. I don’t know if I can type up every thought that goes through my head as I read <em>two</em> manuals. I’ve gotta sleep at some point.</p>
<p>I’m not sure if I will actually need to look at that, though. I guess we’ll find out as we go.</p>
<h1 id=chapter-14-a-simple-nix-expressionhttpswebarchiveorgweb20210227145624httpsnixosorgmanualnixstablech-simple-expression><a href=https://web.archive.org/web/20210227145624/https://nixos.org/manual/nix/stable/#ch-simple-expression>Chapter 14. A Simple Nix Expression</a></h1>
<p>The manual says there are three things I have to do to make a Nix package:</p>
<ol>
<li>Write a file describing all of the sources and dependencies of the package.</li>
<li>Write a shell script that can actually build the package.</li>
<li>Add it to <code>all-packages.nix</code>.</li>
</ol>
<p>Well I don’t wanna do that third thing. I wanna make, like, a local package. Maybe I’ll need to make my own channel? I don’t know. I’m also sort of surprised that (1) and (2) are separate steps? The Nix expression doesn’t describe how to build it? I am surprised, based on the definition of “derivation” as “build action” that I vaguely remember.</p>
<p>Anyway, the manual gives an example of our old friend <code>hello</code>:</p>
<blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=p>{</span> <span class=n>stdenv</span><span class=o>,</span> <span class=n>fetchurl</span><span class=o>,</span> <span class=n>perl</span> <span class=p>}:</span>

<span class=n>stdenv</span><span class=o>.</span><span class=n>mkDerivation</span> <span class=p>{</span>
  <span class=n>name</span> <span class=o>=</span> <span class=s2>"hello-2.1.1"</span><span class=p>;</span>
  <span class=n>builder</span> <span class=o>=</span> <span class=sr>./builder.sh</span><span class=p>;</span>
  <span class=n>src</span> <span class=o>=</span> <span class=n>fetchurl</span> <span class=p>{</span>
    <span class=n>url</span> <span class=o>=</span> <span class=sd>ftp://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz</span><span class=p>;</span>
    <span class=n>sha256</span> <span class=o>=</span> <span class=s2>"1md7jsfd8pa45z73bz1kszpp01yw6x5ljkjk2hx7wl800any6465"</span><span class=p>;</span>
  <span class=p>};</span>
  <span class=k>inherit</span> <span class=n>perl</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></blockquote>
<p>And the manual provides a play by play of every line!</p>
<p>I love that. Great way to present this: every line here is a mystery, so I like that it walks me through each one independently.</p>
<p>Let’s hope I can understand the descriptions.</p>
<blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=p>{</span> <span class=n>stdenv</span><span class=o>,</span> <span class=n>fetchurl</span><span class=o>,</span> <span class=n>perl</span> <span class=p>}:</span>
</code></pre></div></blockquote>
<p>This apparently means that this is a function definition? This is very unfamiliar syntax. I assume that that means instead of (say) the JavaScript syntax <code>param =&gt; body</code>, the Nix syntax would be <code>param: body</code>. And that the one parameter is a record that’s being unpacked? I assume. So we take a record or an associative array or <em>something</em> with three elements: <code>stdenv</code>, <code>fetchurl</code>, and <code>perl</code>. That’s sort of a weird set of arguments for a <em>general</em> package declaration – though I guess that will be sorted out by step (3) in the list up there. I guess that all packages are functions with different signatures, and you have to know how to “invoke” these functions to get your derivation.</p>
<p>Okay. I’ll accept this for now.</p>
<p>Next up, we have:</p>
<blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=n>stdenv</span><span class=o>.</span><span class=n>mkDerivation</span> <span class=p>{</span>
</code></pre></div></blockquote>
<p>The manual doesn’t say this explicitly, but I’m gonna say this: this is the syntax for function invocation. This is just a function call. <code>stdenv.mkDerivation</code> is the function, and the thing delimited by the curly braces is the argument. This is totally normal syntax in Haskell or OCaml or whatever, but I suspect that is totally not obvious if you’re coming from a “normal” language. In JavaScript, this would be <code>stdenv.mkDerivation({ ... })</code>. It’s just that in (this particular family of) “functional programming languages,” people don’t use the parens. There is a very good reason that it is this way, and that reason is called <a href=http://learnyouahaskell.com/higher-order-functions#curried-functions>currying</a>. I don’t know if Nix has curried functions or not, or if functions can only have one argument for other reasons, or what. I’m new here too. Just saying that as background, because it seems like the manual assumes you understand that this is a function call.</p>
<p>Anyway, back to what the manual does say:</p>
<blockquote>
<p>Building something from other stuff is called a <em>derivation</em> in Nix (as opposed to sources, which are built by humans instead of computers).</p>
</blockquote>
<p>Okay. This is the closest we have come to a definition of “derivation” so far. I will meditate on this. I feel like this language is very imprecise, though. Surely <em>the act of</em> building something is not called a “derivation.” That would be crazy. Maybe building something is called “deriving” it? The derivation is like… the description of the thing to build, right?</p>
<p>I do not know.</p>
<blockquote>
<p>We perform a derivation by calling <code>stdenv.mkDerivation</code>.</p>
</blockquote>
<p>“Perform a derivation”? What does that mean??</p>
<blockquote>
<p><code>mkDerivation</code> is a function provided by <code>stdenv</code> that builds a package from a set of <em>attributes</em>.</p>
</blockquote>
<p>“Builds a package”?? Are we building it, or describing it? I thought we needed to write a shell script with the actual build instructions? I’m very confused here.</p>
<blockquote>
<p>A set is just a list of key/value pairs where each key is a string and each value is an arbitrary Nix expression. They take the general form <code>{ name1 = expr1; ... nameN = exprN; }</code>.</p>
</blockquote>
<p>Okay. Not sure why this is called a “set.” This definitely goes against my experience with the term “set” in other contexts. I would call this a “map” or an “associative array” or a “dictionary” or something.</p>
<p>Moving on to the “attributes:”</p>
<blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=n>name</span> <span class=err>=</span> <span class=s2>"hello-2.1.1"</span><span class=p>;</span>
</code></pre></div></blockquote>
<p>It’s interesting that <code>name</code>, which is described as the “human-readable” string, has a version number. I would think the human-readable package name would be <code>hello</code> and the computer-readable package identifier would be <code>hello-2.1.1</code>. But apparently these are reversed? Weird.</p>
<blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=n>builder</span> <span class=err>=</span> <span class=sr>./builder.sh</span><span class=p>;</span>
</code></pre></div></blockquote>
<p>It’s weird to me that <code>./builder.sh</code> isn’t quoted – I am so used to paths just being strings. I guess in Nix they are a first-class type in Nix with their own syntax? That’s neat, if true.</p>
<blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=n>src</span> <span class=err>=</span> <span class=n>fetchurl</span> <span class=p>{</span>
  <span class=n>url</span> <span class=o>=</span> <span class=sd>ftp://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz</span><span class=p>;</span>
  <span class=n>sha256</span> <span class=o>=</span> <span class=s2>"1md7jsfd8pa45z73bz1kszpp01yw6x5ljkjk2hx7wl800any6465"</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></blockquote>
<p><code>fetchurl</code> is one of the arguments to our top-level function. I don’t know why <code>mkDerivation</code> is in <code>stdenv</code> but <code>fetchurl</code> isn’t. Both seem… pretty standard. But okay.</p>
<p>I am curious whether <code>fetchurl</code> just <em>downloads</em> a file or whether it knows how to <code>tar xz</code> it as well. I suppose we shall see once we get to <code>builder.sh</code>.</p>
<p>The manual notes that the <code>src</code> attribute <em>isn’t required</em> – I could call this whatever I want, and have as many different “sources” as I want. Interesting. I suppose we’ll see how to refer to this in <code>builder.sh</code> as well.</p>
<blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>inherit</span> <span class=n>perl</span><span class=p>;</span>
</code></pre></div></blockquote>
<p><code>inherit</code>?? What is this, an object-oriented package manager? I demand to see your supervisor.</p>
<p>No; apparently this is sugar for <code>perl = perl;</code>. In the languages I’m familiar with, <code>{ perl }</code> would be the standard way to say <code>{ perl = perl }</code>. Haskell calls this “punning,” which is a more whimsical term.</p>
<p>So, okay. Once again, I assume we’ll see how to refer to <code>perl</code> – whatever the type of that thing is. The path to a <code>perl</code> binary? The “derivation” for <code>perl</code>? No idea. Let’s find out.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>source</span> <span class=nv>$stdenv</span>/setup

<span class=nv>PATH</span><span class=o>=</span><span class=nv>$perl</span>/bin:<span class=nv>$PATH</span>

tar xvfz <span class=nv>$src</span>
<span class=nb>cd</span> hello-*
./configure --prefix<span class=o>=</span><span class=nv>$out</span>
make
make install
</code></pre></div><p>Huh! Okay. Pretty cavalier attitude towards variable quoting here, eh? Running around with the safety off? I’ll assume that all of these are paths in the Nix store and thus somehow unable to contain spaces (?). So I’ll allow it, tentatively.</p>
<p>More interesting to note: there is no shebang here. Which implies that <code>builder</code> must be a shell script – but I do not know which shell. I get that you <em>probably</em> want a shell script due to the apparent environment variable argument-passing here, but is it possible to write something else? I do not know. Oh, yes I do: a footnote explains that this can be “written in any language, but typically it’s a <code>bash</code> shell script.” Okay. Just a default.</p>
<p>Anyway, let’s go through it line by line:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>source</span> <span class=nv>$stdenv</span>/setup
</code></pre></div><p>See? Isn’t <code>source</code> nicer to read? POSIX be damned.</p>
<p>I don’t know what <code>$stdenv</code> is. I assume this that this is always there / automatically provided by whatever calls the builder, since it doesn’t appear in the “set” (do we really have to call it that?) that we passed to <code>mkDerivation</code>, while some of the other “attributes” appear as variable names here. Obviously it’s a path to some directory, but I don’t know what directory, so I don’t know how to inspect the <code>setup</code> script to see what it needs to do.</p>
<p>I turn to the annotation in the manual, but it doesn’t explain this either. It really adds no information – it is pretty much a recap of the above things that I assumed.</p>
<p>The manual does say that the environment is completely cleared except for the variables set by whatever-calls-this-script – no <code>PATH</code>, for example. Makes sense. I assume you <em>could</em> use an absolute path in here, on purpose, if you wanted. But you don’t want to. Nothing about the working directory that this is run under. Mysterious.</p>
<p>I’d like to read <code>$stdenv/setup</code> but I’m not sure how. Annoying. I turn to the man pages, hoping to find something…</p>
<p>But what? I’m not really sure what page that would even be on. <code>nix-build</code>? No. <code>nix-instantiate</code>? I’m grasping at straws here. No idea.</p>
<p>That script is probably part of the <code>nix</code> package, though – so I should be able to find it in <code>nixpkgs</code>, right?</p>
<pre><code>$ find ~/src/nixpkgs -name 'setup'
</code></pre>
<p>Nope. Ah, right, because it would be an external source…</p>
<pre><code>$ git clone git@github.com:NixOS/nix.git ~/src/nix
$ find ~/src/nix -name 'setup'
</code></pre>
<p>Boooo.</p>
<p>Okay, well, it probably exists <em>somewhere</em> on my file system, right?</p>
<pre><code>$ ls /nix/store | grep stdenv
7nw4bgvwl4w03s6g15279hq52gbc30iy-stdenv-darwin.drv
9879lyvqbj1qifbsm6i7hk4p75jz7afa-bootstrap-stage0-stdenv-darwin.drv
9ack3qyjc26za4flq6awgnp775dldnij-stdenv-darwin.drv
chb0aw1yl97q1p642j58fb0l3jbifrah-bootstrap-stage0-stdenv-darwin.drv
d7apm4hi9bg2fi16x8mzk86chgvb9k8s-bootstrap-stage3-stdenv-darwin.drv
hfqapkz752p7szpavxld8j5vpwi6wc5j-bootstrap-stage2-stdenv-darwin.drv
kcbzm20vy8myjw521wjb2grbchx6h50s-bootstrap-stage3-stdenv-darwin.drv
liacvbiqhxk4505g88b7s27zmqrmpfa4-bootstrap-stage4-stdenv-darwin.drv
llgrpiin4wr33lkpxia3qn5iddf2a5yh-bootstrap-stage4-stdenv-darwin.drv
mdz2bv285gl5q3z5qkivil70lpg03qv5-bootstrap-stage1-stdenv-darwin.drv
qwvpg693ap04clwg0r1wdiprsah4yqfq-bootstrap-stage1-stdenv-darwin.drv
sp860v02a8j8s7vqhjrc94hgsklqdvdw-stdenv-darwin/
v85b3qis3fyi553rb0w30iballqcs8hb-bootstrap-stage2-stdenv-darwin.drv
xi1sgg2rabsz0hkysgw6ld60d9kybv9n-bootstrap-stage2-stdenv-darwin.drv
</code></pre>
<p>Okay. <code>sp860v02a8j8s7vqhjrc94hgsklqdvdw-stdenv-darwin/</code> sounds promising.</p>
<pre><code>$ tree -F /nix/store/sp860v02a8j8s7vqhjrc94hgsklqdvdw-stdenv-darwin
/nix/store/sp860v02a8j8s7vqhjrc94hgsklqdvdw-stdenv-darwin
├── nix-support/
└── setup
</code></pre>
<p>Okay. Just the script, and a weird haunted empty directory.</p>
<p>Okay! Wow. The script is <em>1338</em> lines long. That’s a lotta shell – I will not reproduce it here. But also: come on, Nix maintainers. Trim one line. You’re so close.</p>
<p>What does it do? I don’t know. Sets some environment variables – sets <code>SHELL</code> to be the Nix version of <code>bash</code>, and lots of <code>NIX_</code> things that I don’t know what they do. <code>set -euo pipefail</code>, good good.</p>
<p>The script has quite a few comments, and is broken up into parts: section headers include “hook handling,” “logging,” “error handling” – which sets up an <code>EXIT</code> <code>trap</code> to report failure or build duration. Nice. Then there are the “helper functions” – apparently functions to help the rest of this massive script, not to help in custom builders – then “initialisation” [Europe]. Lots of “hooks” get run throughout this script – I have no idea what a hook is at this stage of my life. I see some <code>shellcheck</code> pragmas, which make me feel warm and fuzzy.</p>
<p>Shoutout to this function:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># Mutually-recursively find all build inputs. See the dependency section of the</span>
<span class=c1># stdenv chapter of the Nixpkgs manual for the specification this algorithm</span>
<span class=c1># implements.</span>
findInputs<span class=o>()</span> <span class=o>{</span>
    ...
<span class=o>}</span>
</code></pre></div><p>Have you ever written a shell script with mutually recursive functions? Are you going to die before you’ve ever truly lived?</p>
<p>I zone out around line 600. Ah, but then we get to “textual substitution functions.” Exciting. And lastly a section called “What follows is the generic builder,” which is a terrible section name. And wow: lotta stuff in the generic builder. Like, over 500 lines of stuff. I do not attempt to understand it.</p>
<p>So, okay. I was mostly curious to know “what Nix-specific functions do I have when writing my builder script,” and I don’t really have an answer to that. There were a lot of functions declared in there, but I don’t know that any of them are meant for <em>me</em>. They seem like… I don’t know what they seem like.</p>
<p>So I’m still a little bit in the dark about why I’d want to source <code>setup</code>. And sure, the exit trap thing is nice, but is it <em>necessary?</em> Is any of this <em>necessary</em>, or is it supposed to be done for <em>my</em> pleasure? Why isn’t it just added automatically by whatever invokes the script? I come away with no answers.</p>
<p>Let’s return to the builder script.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>source</span> <span class=nv>$stdenv</span>/setup

<span class=nv>PATH</span><span class=o>=</span><span class=nv>$perl</span>/bin:<span class=nv>$PATH</span>

tar xvfz <span class=nv>$src</span>
<span class=nb>cd</span> hello-*
./configure --prefix<span class=o>=</span><span class=nv>$out</span>
make
make install
</code></pre></div><p>The whole rest of it is, you know, pretty straightforward. In addition to <code>$stdenv</code>, we have <code>$perl</code>, <code>$src</code>, and <code>$out</code>. <code>$perl</code> and <code>$src</code> were attributes in our input to <code>mkDerivation</code>. But presumably those weren’t <em>strings</em> in our Nix expression – I have no idea what the type of the <code>fetchurl</code> function call is, or really how to think about it right now, but I assume it didn’t <em>download a file</em> and <em>return the file name</em>, the way it would work in, you know, a “normal” language. Nix is a lazily evaluated <em>functional</em> programming language. Expressions can’t have side effects. Right? Right??</p>
<p>So I assume the function call’s result is some sort of value with instructions that Nix knows how to realize when it actually comes time to build, and that the string path that it downloads to is then passed to the <code>builder</code> script in an environment variable. I assume the same thing about <code>perl</code> – that the argument to our <code>hello</code> derivation-making function is not a string, but some sort of abstract representation of the package – perhaps this is what “derivation” means; I still don’t really have any intuition for that term.</p>
<p>The annotations for these lines don’t really seem to back these theories up. They say “The <code>perl</code> environment variable points to the location of the Perl package (since it was passed in as an attribute to the derivation).” But I don’t know if “it” in the parenthetical refers to “the location” or “the Perl package.” Ambiguous.</p>
<p>Similarly: “The <code>src</code> attribute was bound to the result of fetching the Hello source tarball from the network, so the <code>src</code> environment variable points to the location in the Nix store to which the tarball was downloaded.” <em>When</em> was the <code>src</code> attribute bound to the result of fetching the tarball? I am used to separating the determination of what to do from the place that actually does it – there must be some pithy term for that – as seen most obviously in Haskell’s IO type. You can have an <code>IO Int</code>, and you can pass it around, put it in a list, duplicate it, whatever you want: it’s just a recipe. Nothing happens until you ask the runtime to <em>perform</em> the effect.</p>
<p>But maybe the answer is that it actually is performing the side effect as soon as the <code>src</code> field is evaluated – which doesn’t happen until build time. Lazy evaluation means we don’t <em>need</em> an intermediate “type” to pass around. We can delay the network effect until we actually need to turn the result of <code>fetchurl</code> into a string, to pass it to the builder script.</p>
<p>This seems plausible. But I sort of expect, at some point, to be able to load expressions like this up in something like a repl, to inspect its attributes, and get a feel for what it really is. I would be a little surprised if evaluating a single field caused a file to be downloaded, unpacked, put in my <code>/nix/store</code>. That doesn’t mean that’s not how it works! It’s just not what I would expect, coming from general purpose programming languages. I am used to laziness and purity going hand in hand, because compiler optimizations. But maybe Nix has a deterministic evaluation model that makes writing side-effectful code safe? I don’t know.</p>
<p>Anyway. I think this would all be a lot easier to understand if the example had type annotations. Not like you need to change the Nix language or something to add them, but just, like, in a comment, you know? Types make everything so much easier to understand. So much less magical.</p>
<p>Right now I don’t even know what types <em>exist</em> in the Nix language. Strings, presumably. Apparently paths, if the <code>builder = ./builder.sh;</code> line is to be believed. Or are you allowed to have unquoted strings? I have no idea. It’s the first Nix I’ve seen in like five years.</p>
<p>Anyway. I realize I could google this, and find an answer in a few seconds, and then I’d know. But I’m not going to do that yet – I’m going to wait until the manual explains either how it works or teaches me enough so that I can look it up myself in Nix itself.</p>
<p>One interesting thing here, which I didn’t notice but which is called out in the manual is that <code>$out</code> is apparently <em>the final path in the Nix store that this package will go</em>. It’s not some temporary output directory that gets copied into the store. It’s the actual ultimate destination. The manual explains that the “hash” of the package – the prefix of the basename of <code>/nix/store/pakmb65sf3g2hkbm1fdgk2fh6hiij720-hello-2.10</code> – is produced as a hash of the <em>inputs</em> to the derivation, <em>not</em> the hash of the build artifacts, as I would have assumed.</p>
<p>This makes sense once I think about it: in a perfect world, both of these would produce stable hashes, and it wouldn’t matter if you looked at the inputs or the outputs. But the inputs are known immediately, whereas knowing the outputs requires you to actually build the thing, so picking the inputs allows you to request that exact package from a binary cache – you know in advance what the fully hashed name will be, without needing to specify it as a sort of checksum thing, so it makes the perfect ID.</p>
<p>Of course, in the real world, I also imagine you would have a <em>lot</em> of insignificant variations in the output that would make the hashes very unstable across multiple builds and multiple machines. Trying to package pre-existing software in Nix that does not care deeply about having perfectly reproducible builds is probably going to result in a lot of packages with not-perfectly-reproducible builds.</p>
<p>Tangent: it’s annoying that hashes appear at the <em>beginning</em> of the paths in the Nix store, instead of at the end. You can’t just type <code>cd /nix/store/hello &lt;TAB&gt;</code> and autocomplete the full path. I mean, <em>I</em> can do that, because my shell autocomplete looks at the whole filename if it can’t find a prefix match. I don’t know if this is some option I enabled at some point or if it’s just a Neat Thing that <code>zsh</code> does out of the box, but this is definitely not the default behavior in <code>bash</code>, and I assume that like 80% of developers just use default <code>bash</code>. So I imagine it would be annoying for them.</p>
<p>I guess there are tradeoffs either way, but this makes the store feel less like a directory that I can just dive into and explore and more like a database that I have to interact with with special tools. Maybe that’s good? I dunno. I don’t really know what those tools are yet.</p>
<p>Anyway. Tangent over.</p>
<p>It’s interesting that we are writing directly to the final <code>$out</code> path. I assume this is because, you know, a lot of software is more than just some binary: it might be some binary that contains an absolute path to some library that it also built by the same makefile, so you couldn’t just build it in a temporary location and then <code>mv</code> it into its final resting place unless you somehow rewrote the paths in the binary – and that would be crazy. I mean, as someone who is pretty used to writing simple statically-linked executables, it seems sort of <em>icky</em> to have software that “must” live in one place. But it is all around us, and Nix must deal with it.</p>
<p>But it makes me think about what happens when a build fails: do I end up with bogus temporary build artifacts in my store? Presumably the <code>$out</code> path is deleted, but is this what the “valid paths” thing from the glossary was talking about? What if I’m doing a <em>rebuild</em> of a package I already have installed? Probably the <code>$out</code> directory is removed before the build starts, and re-created from scratch each time. Seems like the safest way, so I’ll assume that’s what happens. But it makes sense now how there might be paths in the Nix store that are either temporarily (while building) or permanently (in the case that cleanup failed) “invalid.” And you can’t track validity in the <code>/nix/store/whatever</code> directory itself – how would you ensure no collisions with build artifacts? – so it makes sense that the “database” remembers that.</p>
<p>Okay. Section over.</p>
<p>We learned a bit, but we did not learn how to actually <em>use</em> any of this. I would like to follow along at home and actually try building this derivation – but I have no idea how. I saw some Nix and some shell, in isolation, with no idea where they go or how to use them.</p>
<p>Sad. Hopefully we’ll get to that soon – but I think this as good a time as any for a break.</p>
<hr>
<ul>
<li>What does the function <code>mkDerivation</code> <em>actually do?</em> What does it “return”? What side effects does it have?</li>
<li>Why does Nix call maps “sets”?</li>
<li>Are paths a first-class type in Nix?</li>
<li>Can I put a space in a Nix package name?</li>
<li>How do “special” paths like <code>stdenv-darwin</code> wind up in the store / stay in the store? Are those part of the <code>nix</code> package?</li>
<li>What is a hook?</li>
<li>Do I have to <code>source $stdenv/setup</code>? If so, why?</li>
<li>When are the side effects of <code>fetchurl</code> actually executed?</li>
<li>Why do hashes appear at the beginning of store paths instead of the end?</li>
</ul></div>
</article>
<div class=post-footer>
<a href="mailto:ianthehenry@gmail.com?subject=let%27s%20talk%20about%20%22My%20first%20derivation%22&amp;body=First%20of%20all,%20I%20just%20wanted%20to%20say%20that%20I%20forgive%20you%20for%20not%20having%20a%20real%20comment%20system%20on%20your%20site.">comment on this post</a><a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>Next up ➜ Okay my actual first derivation</a></div>
<aside class=series-rider>
<p>
This post is part of the series <a class=series-name href=https://ianthehenry.com/posts/how-to-learn-nix/>How to Learn Nix</a>.
You can
<a target=_blank href=https://ianthehenry.com/feed.xml>subscribe to my RSS feed</a>
or
<a target=_blank href=https://twitter.com/ianthehenry>follow me on Twitter</a>
for more, or <a href=https://ianthehenry.com/posts/>peruse my back catalog</a> if you're in the mood for something different.
<div class=subsection-header>Opening remarks</div><ol start=1 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/introduction/>What's all this about?</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/prior-knowledge/>Prior knowledge</a></li>
</ol><div class=subsection-header>Reading the Nix manual</div><ol start=3 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/glossary/>What we talk about when we talk about Nix</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/quick-start-guide/>Quick starts, full hearts</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/basic-package-management/>Basic package management</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/profiles/>Profiles</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/garbage-collection/>Garbage collection</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/channels/>Channels</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/sharing/>Learning to share</a></li>
<li><strong><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/>My first derivation</a></strong>&nbsp;←&nbsp;you are here</li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>Okay my actual first derivation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-language/>The Nix expression language</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/derivations/>Derivations</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/built-in-functions/>Built-in Functions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/advanced-topics/>Advanced Topics</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/command-reference/>Command Reference</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/configuration/>Configuration</a></li>
</ol><div class=subsection-header>Interlude: in which we follow our hearts, however briefly</div><ol start=18 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-manual-reflection/>So I read the manual huh</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/switching-from-homebrew-to-nix/>Switching from Homebrew to Nix</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-nix-bug/>My first Nix bug</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-package-upgrade/>My first package upgrade</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/declarative-user-environment/>Setting up a declarative user environment</a></li>
</ol><div class=subsection-header>Reading the Nixpkgs manual</div><ol start=23 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/how-to-learn-nixpkgs/>How to learn Nixpkgs</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/overlays/>Overlays</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/overriding/>Overriding</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/an-infinite-list-of-functions/>An infinite list of functions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/even-more-functions-somehow/>Even more functions, somehow</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/the-standard-environment/>The standard environment</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/derivations-in-detail/>Derivations in detail</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/cross-compilation/>Cross-compilation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/platform-notes/>Platform notes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/builders/>Builders</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/languages-and-frameworks/>Languages and frameworks</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/random-package-grab-bag/>Random package grab-bag</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/how-to-give-back/>How to give back</a></li>
</ol><div class=subsection-header>Documentation behind us, we set out on our own</div><ol start=36 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nixpkgs-reflection/>So I read the other manual, huh</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>Saving your shell</a></li>
</ol><div class=subsection-header>Oh right forgot about Nix Pills</div><ol start=38 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>Nix Pills</a></li>
</ol><div class=subsection-header>Our whole lives ahead of us</div><ol start=39 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/python3-alpha/>How to install Python</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/open-questions/>Open questions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/ambiguous-packages/>Ambiguous packages</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-zshell/>Running zsh in nix-shell</a></li>
</ol><div class=subsection-header>Nix 2.4 slithers to life</div><ol start=43 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/flakes/>My first brush with flakes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/more-flakes/>More flakes, unfortunately</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/new-profiles/>Fancy new profiles</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/chipping-away-at-flakes/>Chipping away at flakes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-develop/>New and unimproved shells</a></li>
</ol>
</aside>
</main>
<footer>
© 1899-1907 <a href=https://ianthehenry.com/about/>Ian Henry</a>
</footer>
