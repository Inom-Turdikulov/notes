<!DOCTYPE html> <html lang=en style><!--
 Page saved with SingleFile 
 url: https://ianthehenry.com/posts/how-to-learn-nix/an-infinite-list-of-functions/ 
 saved date: Mon Jul 17 2023 13:35:08 GMT+0600 (Kyrgyzstan Time)
--><meta charset=utf-8>
<meta name=viewport content="initial-scale=1,maximum-scale=1">
<title>How to Learn Nix, Part 26: An infinite list of functions</title>
<link rel=canonical href=https://ianthehenry.com/posts/how-to-learn-nix/an-infinite-list-of-functions/>
<style>:root{--box-radius:6px;--outer-box-radius:10px}:root{--content-bg:#fff;--gutter-bg:#eeeef3;--text-fg:#4d4d4c;--table-border-color:#ccc;--separator-color:#6d6d6c;--link:#07c;--link-visited:#751a9a;--blockquote-accent:var(--link);--footnote-accent:#ffd2a3;--subscribe-button-bg:#44e66c;--subscribe-button-fg:#11391b;--media-controls-on:#34b553;--media-controls-contrast:#fff;--inline-code-bg:#f3f3fa;--code-block-bg:#f3f3fa;--aside-bg:#f3f3fa;--aside-warning-bg:#fff5d1;--aside-warning-fg:#ac3233;--palette-red:#c82829;--palette-green:#718c00;--palette-yellow:#eab700;--palette-orange:#f5871f;--palette-blue:#4271ae;--palette-purple:#8959a8;--palette-teal:#3e999f;--palette-white:#fefefe;--palette-black:#000;--palette-text:var(--text-fg);--palette-dim:#8e908c;--highlight-bg:var(--palette-yellow);--highlight-fg:var(--text-fg)}#dmt::before{content:"🌖"}#dmt:hover::before{content:"🌗"}@media (prefers-color-scheme:dark){:root:not(.light-theme){--content-bg:#313233;--gutter-bg:#1d1f21;--text-fg:#d8d4cf;--table-border-color:#ccc;--separator-color:#6d6d6c;--link:rgb(82,183,255);--link-visited:rgb(193,104,229);--blockquote-accent:var(--link);--footnote-accent:#a8612f;--subscribe-button-bg:#44e66c;--subscribe-button-fg:#11391b;--media-controls-on:#44e66c;--media-controls-contrast:#11391b;--inline-code-bg:#3c4044;--code-block-bg:#1d1f21;--aside-bg:#3c4044;--aside-warning-bg:#fff5d1;--aside-warning-fg:var(--palette-red);--palette-red:#cc6666;--palette-green:#b5bd68;--palette-yellow:#f0c674;--palette-orange:#de935f;--palette-blue:#81a2be;--palette-purple:#b294bb;--palette-teal:#8abeb7;--palette-white:#fefefe;--palette-black:#000;--palette-text:var(--text-fg);--palette-dim:#969896;--highlight-bg:var(--palette-yellow);--highlight-fg:var(--palette-black)}:root:not(.light-theme) #dmt::before{content:"🌒"}:root:not(.light-theme) #dmt:hover::before{content:"🌓"}}#dmt{width:30px;text-align:right;padding-right:4px;position:absolute;top:0;bottom:0;right:0;border:none;background-color:inherit;cursor:pointer}*{margin:0;padding:0;font:inherit;box-sizing:border-box}html{background-color:var(--gutter-bg);color:var(--text-fg)}body{font-family:system-ui,sans-serif;font-size:12pt;line-height:1.8;word-wrap:break-word}body:not(.content-page) main>aside{padding:0 var(--content-padding)}body.content-page main,body:not(.content-page) article{background-color:var(--content-bg);border-radius:var(--outer-box-radius);padding:var(--content-padding)}pre{word-wrap:normal}em,i{font-style:italic}h1>a:only-child,h2>a:only-child{display:block}main .subsection-header+.post-list{margin-top:0}strong{font-weight:700}ol,ul{padding-left:3ch}hr{border-style:solid;border-width:1.5px 0 0;border-radius:1px;border-color:var(--separator-color)}:not(pre)>code{white-space:pre;background-color:var(--inline-code-bg)}li{padding-left:0}blockquote{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:"";content:none}a,a:active,a:visited{text-decoration:none}a:hover{text-decoration:underline}blockquote{padding:0 0 0 var(--content-padding);border-left:solid 2px var(--blockquote-accent)}aside{--content-padding:0.5em;padding:.5em;border-radius:var(--box-radius);background-color:var(--aside-bg)}a,a:active,header a:visited,footer a:visited,h1 a:visited,h2 a:visited{color:var(--link)}a:visited{color:var(--link-visited)}h1{font-size:130%}h2{font-size:120%}main *+p,main *+pre,main *+aside,main *+article,main *+blockquote,main *+div,main *+ul,main *+ol,main *+hr,main *+h1,main *+h2{margin-top:1em}main pre+div.highlight,main div.highlight+pre{margin-top:1px}main .post-header *+h1{margin-top:0}code{font-family:Menlo,monospace;padding:0 3px;border-radius:2px}pre{background-color:var(--code-block-bg);font-size:11pt;padding:calc(.75*var(--content-padding)) var(--content-padding);line-height:1.3;border-radius:var(--box-radius);overflow-x:scroll;-webkit-overflow-scrolling:touch}pre code{padding:0;border-radius:0;display:inline-block;background-color:initial}p+p{margin-top:1em}body{margin:0 auto;--content-padding:10px;max-width:768px;-webkit-text-size-adjust:100%;position:relative}header{position:relative}header>*{height:48px;line-height:48px}.promo,.promo:visited,.promo:active{display:block;text-align:center;background-color:var(--link);color:var(--code-block-bg);border-radius:0 0 var(--outer-box-radius) var(--outer-box-radius)}header .site-title{font-size:130%}header nav{position:absolute;right:30px;top:0}@media all and (max-width:400px){:root{--outer-box-radius:0}header{text-align:center}header nav{position:static}:not(pre)>code{white-space:pre-wrap}body{--content-padding:10px}#dmt{padding:0;text-align:center;width:40px}}header ul{padding:0}header li{list-style:none;display:inline-block}header a{display:block;height:100%}header li+li{margin-left:1em}footer{padding:2em 0;font-size:.85em;text-align:center}article h1.post-title{font-size:200%}article .post-title a{display:block}article .meta{font-size:90%;font-style:italic}.post-header h1{line-height:1.2em;margin-bottom:.5em}.post-footer{text-align:center}.post-footer a{display:block}ol.post-list{list-style-position:inside;padding:0}.series-rider .series-name{font-style:italic}.highlight{color:var(--palette-text)}.highlight .err{color:var(--palette-red)}.highlight .k{color:var(--palette-purple)}.highlight .n{color:var(--palette-text)}.highlight .o{color:var(--palette-teal)}.highlight .p{color:var(--palette-text)}.highlight .cm{color:var(--palette-dim)}.highlight .kn{color:var(--palette-teal)}.highlight .nb{color:var(--palette-text)}.highlight .no{color:var(--palette-red)}.highlight .mi{color:var(--palette-orange)}.highlight .s2{color:var(--palette-green)}.highlight .sr{color:var(--palette-green)}</style>
<meta property=og:title content="How to Learn Nix, Part 26: An infinite list of functions">
<meta property=og:type content=website>
<meta property=og:url content=https://ianthehenry.com/posts/how-to-learn-nix/an-infinite-list-of-functions/>
<meta name=description content="Oh gosh. I’ve been really putting off chapter five because, well, because look at it. It’s massive. It’s intimidating.
But as I recall from the Nix manual, the reference sections do not make the most exciting reading, but they are usually very educational. So I can’t just skip them.
Even if I really want to skip them.">
<meta property=og:description content="Oh gosh. I’ve been really putting off chapter five because, well, because look at it. It’s massive. It’s intimidating.
But as I recall from the Nix manual, the reference sections do not make the most exciting reading, but they are usually very educational. So I can’t just skip them.
Even if I really want to skip them.">
<meta property=og:image content=https://ianthehenry.com/checkerboard.png>
<meta name=twitter:creator content=@ianthehenry>
<meta name=twitter:card content=summary>
<link type=image/x-icon rel="shortcut icon" href="data:image/vnd.microsoft.icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAHH1uIDShg/xEsZv8GFk3/CSJb/wgZT/8IGU//CBlP/wkiW/8HGE7/CBlP/wkiW/8HIFX/BxhO/wcgVf8OK2t7JDhz/wcfW/8NNn7/CSpq/wkjYf8MJGP/DCJg/w02ef9SqdX/TKHJ/1my2f9Moc3/UqzV/1Cr1v9Pocf/Ditr/xk2cf8KJGL/CjR8/wwva/8RK2r/Cido/w8qa/8LLW//TqjT/1Gnz/9bsNf/Sp/K/1Wt2f9Wrtj/UKjQ/w8xc/8gPHj/Di5w/xk4ef8TL27/Dy5u/xU3fv8QLGv/Ditr/1qy3f9dttv/Yrje/0ecx/9Knsz/U6fQ/1m13f8YN3n/JjZx/wszdv8YOXz/Eilm/xc3e/8dSZT/GDJz/xk/hv9hu+P/WbHZ/1mv1v9Kn8z/WLHd/1212v9ds9n/Eipr/xcqYv8SOX3/GzRz/xQrZ/8aM3D/HEuU/xc0df8fPYD/Yrre/1603P9dt9z/VKvY/1iz4v9etNr/Y73m/xk5fP8cMm3/JEWK/xc0dP8eO3v/Hjd4/ydRnP8WM3P/Gjd3/2bA5/9dtd//Ybng/2K95v9ct+P/Ybnf/2K95/8oS5L/GChg/xxBh/8lSIz/GC5s/yM5ev8hRoz/HTp7/yE6e/9Zsdz/YLzn/2jF7v9ryfL/YLzn/1qu1f9htdz/GDyD/y0/ev9qx/X/acDn/1235v9euun/Yb3r/1665v9owu7/GUOL/yhGh/8nUJL/MkmI/yBFiP8jOHb/MVag/yM+gv8VMGv/acXx/27G7/9szv3/bMb1/2zD6/9vy/X/edf5/yBHjv8yS47/JEuO/zVLiv8nS5D/LkOB/yRXpP8lQoT/H0WI/3fS+P910Pf/b8/8/2bB7/991Pn/eNb+/3nT+P8pS5L/O1GS/ytUnP86UJH/NF2k/zNLjP8sXKv/JkCB/x4+ff+B2/3/etT9/4He//922f//fNf//3TT//991/7/NU6N/zZSkP86Zav/PlWR/zFepv88ZKb/MF2n/yQ/gf8bNXH/fd3//3/b//+K6P//ft///3vV//993f//gdz//0hWlf9FZKX/RmOj/0JXlv9IeMP/QXKz/0Jsuf8eO3z/Hjt2/3vd//+C3v//ju3//3zg//+H4v//guL//4nj//9HXp3/UGur/ztgqf9JYqP/S3G4/05ur/9EbLT/Hjt7/zNJhf+G4///heT//4rq//+E5///iOT//4jr//+G4///UXO0/09iov9EX6H/SWWn/1V5wP9Kaa7/RGSp/ydLj/8NKGCfDShg/x8+d/8RLGb/CBlP/wYWTf8GFEj/CBNH/wooZP8JIlv/CCJd/woWSf8HGE7/ByBV/wwgU/8fO3mfAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
<body class=content-page>
<a class=promo href=https://janet.guide/ target=_blank><i>psst, hey kid, wanna read a weird programming book</i></a>
<header>
<a class=site-title href=https://ianthehenry.com/>Ian Henry</a>
<nav>
<ul><li><a href=https://ianthehenry.com/about/>About</a><li><a href=https://ianthehenry.com/posts/>Blog</a><li><a href=https://ianthehenry.com/stuff/>Stuff</a></ul>
</nav>
<button id=dmt title="Toggle dark mode"></button>
</header>
<main>
<aside class=series-rider>
<p>This post is part of the series <a class=series-name href=https://ianthehenry.com/posts/how-to-learn-nix/>How to Learn Nix</a>, a rambling diary in which I work my way through the Nix manual in excrutiating detail.</p>
</aside>
<article class=post>
<div class=post-header>
<time class=meta datetime=2021-04-11>April 11, 2021</time>
<h1 class=post-title>
<a href=https://ianthehenry.com/posts/how-to-learn-nix/an-infinite-list-of-functions/>How to Learn Nix, Part&nbsp;26:<br>An infinite list of functions</a></h1>
</div>
<div class=post-content><p>Oh gosh. I’ve been really putting off <a href=https://web.archive.org/web/20210318102415if_/https://nixos.org/manual/nixpkgs/stable/#chap-functions>chapter five</a> because, well, because <em>look at it</em>. It’s massive. It’s intimidating.</p>
<p>But as <a href=https://ianthehenry.com/posts/how-to-learn-nix/built-in-functions/>I recall</a> from <a href=https://ianthehenry.com/posts/how-to-learn-nix/command-reference/>the Nix manual</a>, the reference sections do not make the most <em>exciting</em> reading, but they are usually very educational. So I can’t just skip them.</p>
<p>Even if I really want to skip them.</p>
<h1 id=51-nixpkgs-library-functionshttpswebarchiveorgweb20210318102415if_httpsnixosorgmanualnixpkgsstablesec-functions-library><a href=https://web.archive.org/web/20210318102415if_/https://nixos.org/manual/nixpkgs/stable/#sec-functions-library>5.1 Nixpkgs Library Functions</a></h1>
<p>I’ve seen <code>lib</code> before, and wondered what it was, and why it was different from <code>builtins</code>. I suppose that now I’m going to find out.</p>
<p>This section is broken up into multiple subsections. In this order, they are:</p>
<ol>
<li>Assert functions</li>
<li>Attribute-set functions</li>
<li>String manipulation functions</li>
<li>Miscellaneous functions</li>
<li>List manipulation functions</li>
<li>Debugging functions</li>
<li>NixOS / nixpkgs option handling</li>
</ol>
<p>This is the first time I have seen the term “attribute-set.” The Nix manual exclusively used the bare term “set,” and I was surprised by the <code>builtins.isAttrs</code> function (instead of <code>builtins.isSet</code>). I thought at the time that this was just because <code>isSet</code> is a very ambiguous name – it’s not clear if “set” is a verb or a noun in there.</p>
<p>But now I think that I’m seeing some archaeological evidence that this type was originally called “attribute-set.” I can imagine that, over time, Nix users got tired of saying “attribute-set” all the time, so they started just saying “set,” and everyone knew that it was short for “attribute-set,” and peace reigned throughout the kingdom. But this went on for so long that eventually the abbreviation was reflected in the documentation, and the manual, and everywhere else, and the name “attribute set” fell into legend. And one day newcomers arrived from the neighboring kingdom, and they kept hearing the word “set,” and they were very confused that the Nixites chose a word that already has a pretty well-established and different meaning for this core concept, and many of them returned to their homes, repulsed, but some others stayed, because so many of the customs here were strange and foreign, and they were determined to broaden their minds. And eventually, after befriending some of the locals, they heard whisper of the term “attribute set,” and they realized that perhaps the Nixites were not completely crazy, just victims of an unfortunate linguistic evolution that was deeply ingrained in their culture.</p>
<p>Sigh I guess I actually have to read this chapter now.</p>
<p>I am delighted to report that these functions actually have type signatures, <em>unlike</em> the functions in the Nix manual. That will make it much easier to follow along at home.</p>
<h2 id=511-assert-functionshttpswebarchiveorgweb20210318102415if_httpsnixosorgmanualnixpkgsstablesec-functions-library-asserts><a href=https://web.archive.org/web/20210318102415if_/https://nixos.org/manual/nixpkgs/stable/#sec-functions-library-asserts>5.1.1 Assert functions</a></h2>
<p>The assertion functions are pretty simple – they extend <code>assert</code> expressions with error messages. It looks like they’re implemented in terms of <code>trace</code>, which appears to be the only way to print things in Nix? I’m basing that on this example:</p>
<blockquote>
<pre tabindex=0><code>assert lib.asserts.assertMsg ("foo" == "bar") "foo is not bar, silly"
stderr&gt; trace: foo is not bar, silly
stderr&gt; assert failed
</code></pre></blockquote>
<p>Wait okay this is not as simple as I thought. How do I… parse that? There’s no semicolon there. I thought assert expressions needed semicolons. What’s going on here?</p>
<pre tabindex=0><code>$ nix repl
Welcome to Nix version 2.3.10. Type :? for help.

nix-repl&gt; lib = (import &lt;nixpkgs&gt;).lib

nix-repl&gt; assert lib.asserts.assertMsg (1 == 2) "message"

</code></pre><p>Aha. Okay. Good. I hit enter, but it’s still expecting input, because there was no semicolon, so it’s still scanning. I am reassured. The example is just wrong.</p>
<pre tabindex=0><code>nix-repl&gt; assert lib.asserts.assertMsg (1 == 2) "message"; 1
error: value is a function while a set was expected, at (string):1:2
</code></pre><p>Hmmm. Well that’s… what? The type signature given is <code>assertMsg :: Bool -&gt; String -&gt; Bool </code>. So… no sets that I can see? The only function in question here is <code>lib.asserts.assertMsg</code>. Which… is a function, right?</p>
<pre tabindex=0><code>nix-repl&gt; lib.asserts.assertMsg
error: value is a function while a set was expected, at (string):1:2
</code></pre><p>Oh. Ha. Okay, I don’t feel <em>that</em> dumb here.</p>
<p>Have you spotted it yet? The error refers not to the line we typed, but to the line we started with:</p>
<pre tabindex=0><code>nix-repl&gt; lib = (import &lt;nixpkgs&gt;).lib
</code></pre><p>I forgot to call <code>import &lt;nixpkgs&gt;</code>. But because laziness, it didn’t actually evaluate that expression until we used it. So the error didn’t show up until later.</p>
<p>A little confusing! I could see this confusing someone for quite some time, but fortunately it was but a minor setback on my road towards asserting nonsense. Once more, with feeling:</p>
<pre tabindex=0><code>nix-repl&gt; lib = (import &lt;nixpkgs&gt; {}).lib

nix-repl&gt; assert (lib.asserts.assertMsg (1 == 2) "message")
          ; 1
trace: message
error: assertion (((lib).asserts.assertMsg  (1 == 2))  "message") failed at (string):1:1
</code></pre><p>Yes, okay; the example is a little stale.</p>
<p>The only other assert function is given as:</p>
<pre tabindex=0><code>assertOneOf :: String -&gt; String -&gt; StringList -&gt; Bool 
</code></pre><p>Which is a strange signature – the first string is the name of the variable, and the second is the value. The example says:</p>
<blockquote>
<pre tabindex=0><code>let sslLibrary = "bearssl";
in lib.asserts.assertOneOf "sslLibrary" sslLibrary [ "openssl" "bearssl" ];
=&gt; false
stderr&gt; trace: sslLibrary must be one of "openssl", "libressl", but is: "bearssl"
</code></pre></blockquote>
<p>Now if you look closely you can see that this example is nonsensical; the list does not match the error message, and in fact that expression does not fail the assertion at all. If we modify it so that it does:</p>
<pre tabindex=0><code>nix-repl&gt; let sslLibrary = "bearssl"; in lib.asserts.assertOneOf "sslLibrary" s
slLibrary [ "openssl" "libressl" ]
trace: sslLibrary must be one of [
  "openssl"
  "libressl"
], but is: "bearssl"
false
</code></pre><p>We can see the output has gotten a little bit fancier.</p>
<p>I confirm that <code>lib.asserts</code> still only contains these two functions, even though I believe the Nixpkgs manual is several months older than the Nixpkgs that I am using today. I assume it’s only updated after Nix releases, and 2.3.10 came out in December 2020 (it is now the beginning of April 2021).</p>
<h1 id=512-attribute-set-functionshttpswebarchiveorgweb20210318102415if_httpsnixosorgmanualnixpkgsstablesec-functions-library-attrset><a href=https://web.archive.org/web/20210318102415if_/https://nixos.org/manual/nixpkgs/stable/#sec-functions-library-attrset>5.1.2. Attribute-Set Functions</a></h1>
<p>Lots of functions for dealing with “paths” – lists of string key names. Pretty simple. Also dealing with lists of keys… honestly I have no idea when I would expect these functions to live in <code>builtins</code> or in <code>lib</code>. These <em>seem</em> to be high-level helpers? Like, maybe <code>builtins</code> is the minimum necessary functionality out of which all the helpers can be built?</p>
<p>And maybe <code>lib</code> mirrors every function from <code>builtins</code>, so you don’t need to remember which live in which and you can always just use <code>lib.attrsets</code> and everything will just work?</p>
<p>Nope. I checked. You have to remember which functions are in <code>lib</code> and which are in <code>builtins</code>. Alas.</p>
<p>I weakly try a few examples to see if they still work.</p>
<pre tabindex=0><code>nix-repl&gt; catAttrs "a" [{a = 1;} {b = 0;} {a = 2;}]
error: undefined variable 'catAttrs' at (string):1:1

nix-repl&gt; lib.catAttrs "a" [{a = 1;} {b = 0;} {a = 2;}]
[ 1 2 ]

nix-repl&gt; lib.attrsets.catAttrs "a" [{a = 1;} {b = 0;} {a = 2;}]
[ 1 2 ]
</code></pre><p>A lazy copy and paste taught me that I don’t need to type <code>lib.attrsets.function</code>. I can just type <code>lib.function</code>. Is that true… for all of these functions? Some of these functions? The manual has not yet said anything about this.</p>
<p>Wow. We get into some pretty specific helpers here.</p>
<blockquote>
<pre tabindex=0><code>mapAttrsRecursiveCond :: (AttrSet -&gt; Bool) -&gt; ([ String ] -&gt; Any -&gt; Any) -&gt; AttrSet -&gt; AttrSet
</code></pre></blockquote>
<p>I’m just… you don’t need to use that function; you don’t need to understand it. If you do need to use it, you’ll know.</p>
<p>Whoa! We have just hit a major breakthrough.</p>
<blockquote>
<pre tabindex=0><code>isDerivation :: Any -&gt; Bool 
</code></pre><p>Check whether the argument is a derivation. Any set with <code>{ type = "derivation"; }</code> counts as a derivation.</p>
</blockquote>
<p>Is <em>that</em> what a derivation is? Have we finally caught a live one?</p>
<pre tabindex=0><code>nix-repl&gt; { x = 1; }
{ x = 1; }

nix-repl&gt; { x = 1; type = "derivation"; }
«derivation ???»
</code></pre><p>!!!</p>
<p>We did it. It only took us until part 26 to finally have an answer to the question “what is a derivation.” The answer is… well, you just saw. The answer is it’s a set. With a particular key.</p>
<p>That’s – well, that’s what it means for the <code>isDerivation</code>, and that’s what it means for <code>nix repl</code>, apparently. But is it actually?</p>
<pre tabindex=0><code>nix-repl&gt; (import &lt;nixpkgs&gt; {}).hello
«derivation /nix/store/6dh5ds3dnrkl995wg767mq9iw6pfg8f1-hello-2.10.drv»

nix-repl&gt; (import &lt;nixpkgs&gt; {}).hello // { type = ""; }
{
  __darwinAllowLocalNetworking = false;
  __ignoreNulls = true;
  __impureHostDeps = [ ... ];
  __propagatedImpureHostDeps = [ ... ];
  __propagatedSandboxProfile = [ ... ];
  __sandboxProfile = "";
  all = [ ... ];
  args = [ ... ];
  buildInputs = [ ... ];
  builder = "/nix/store/l25gl3siwmq6gws4lqlyd1040xignvqw-bash-4.4-p23/bin/bash";
  configureFlags = [ ... ];
  depsBuildBuild = [ ... ];
  depsBuildBuildPropagated = [ ... ];
  depsBuildTarget = [ ... ];
  depsBuildTargetPropagated = [ ... ];
  depsHostHost = [ ... ];
  depsHostHostPropagated = [ ... ];
  depsTargetTarget = [ ... ];
  depsTargetTargetPropagated = [ ... ];
  doCheck = true;
  doInstallCheck = false;
  drvAttrs = { ... };
  drvPath = "/nix/store/6dh5ds3dnrkl995wg767mq9iw6pfg8f1-hello-2.10.drv";
  inputDerivation = «derivation /nix/store/rglwjg1sqfwwnskgi7h7h7kj6d3pxmrj-hello-2.10.drv»;
  meta = { ... };
  name = "hello-2.10";
  nativeBuildInputs = [ ... ];
  out = «derivation /nix/store/6dh5ds3dnrkl995wg767mq9iw6pfg8f1-hello-2.10.drv»;
  outPath = "/nix/store/70pxcwpdiq7ddrk4w8axfl51s9xh9ahn-hello-2.10";
  outputName = "out";
  outputUnspecified = true;
  outputs = [ ... ];
  override = { ... };
  overrideAttrs = «lambda @ /nix/store/mi0xpwzl81c7dgpr09qd67knbc24xab5-nixpkgs-21.05pre274251.f5f6dc053b1/nixpkgs/lib/customisation.nix:85:73»;
  overrideDerivation = «lambda @ /nix/store/mi0xpwzl81c7dgpr09qd67knbc24xab5-nixpkgs-21.05pre274251.f5f6dc053b1/nixpkgs/lib/customisation.nix:84:32»;
  passthru = { ... };
  patches = [ ... ];
  pname = "hello";
  propagatedBuildInputs = [ ... ];
  propagatedNativeBuildInputs = [ ... ];
  src = «derivation /nix/store/njch6qh4l5k42bz14fya766l0piyvril-hello-2.10.tar.gz.drv»;
  stdenv = «derivation /nix/store/v1fmdbwdgqds6b4icqzyin0anag03dz3-stdenv-darwin.drv»;
  strictDeps = false;
  system = "x86_64-darwin";
  type = "";
  userHook = null;
  version = "2.10";
}
</code></pre><p>Aha! We have finally managed to observe our first actual derivation in the wild (cosmetics by yours truly; I <em>still</em> have no idea how to pretty-print a Nix expression). I could never figure out how to get <code>nix repl</code> to show me that before now.</p>
<p>All <em>kinds</em> of good stuff in there. But it’s a lot to read. I don’t know how much of that is primitive stuff common to any derivation and how much of it is niceties like <code>overrideAttrs</code> and friends.</p>
<p>So let’s go back to <a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>my first derivation</a>, which is just about the “simplest” derivation I can think of. But first, a refresher of where we left it:</p>
<pre><code>cat ~/scratch/hello.nix
</code></pre>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=p>{</span> <span class=n>stdenv</span> <span class=p>}:</span>

<span class=nb>derivation</span> <span class=p>{</span>
  <span class=k>inherit</span> <span class=n>stdenv</span><span class=p>;</span>
  <span class=n>system</span> <span class=o>=</span> <span class=s2>"x86_64-darwin"</span><span class=p>;</span>
  <span class=n>name</span> <span class=o>=</span> <span class=s2>"my-hello-1.0"</span><span class=p>;</span>
  <span class=n>builder</span> <span class=o>=</span> <span class=n>stdenv</span><span class=o>.</span><span class=n>shell</span><span class=p>;</span>
  <span class=n>args</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>"-e"</span> <span class=sr>./builder.sh</span> <span class=p>];</span>
  <span class=n>messagefile</span> <span class=o>=</span> <span class=sr>./message.txt</span><span class=p>;</span>
  <span class=n>outputs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>"foo"</span> <span class=s2>"out"</span><span class=p>];</span>
  <span class=n>shellHook</span> <span class=o>=</span> <span class=s2>"PS1='sup$ '"</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>And in motion:</p>
<pre tabindex=0><code>nix-repl&gt; (import ~/scratch/hello.nix { inherit (nixpkgs) stdenv; }) // { type = "divination"; }
{
  all = [ ... ];
  args = [ ... ];
  builder = "/nix/store/l25gl3siwmq6gws4lqlyd1040xignvqw-bash-4.4-p23/bin/bash";
  drvAttrs = { ... };
  drvPath = "/nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv";
  foo = «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv»;
  messagefile = /Users/ian/scratch/message.txt;
  name = "my-hello-1.0";
  out = «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv»;
  outPath = "/nix/store/8x0zx1p2k76abcmmp6la239ybwa7p1nd-my-hello-1.0-foo";
  outputName = "foo";
  outputs = [ ... ];
  shellHook = "PS1='sup$ '";
  stdenv = «derivation /nix/store/v1fmdbwdgqds6b4icqzyin0anag03dz3-stdenv-darwin.drv»;
  system = "x86_64-darwin";
  type = "divination";
}
</code></pre><p>Well that’s a <em>lot</em> tamer looking. So tame that I expect we can afford to look at the whole thing:</p>
<pre tabindex=0><code>nix-repl&gt; :p (import ~/scratch/hello.nix { inherit (nixpkgs) stdenv; }) // { type = "divination"; }
{
  all = [ «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv» «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv» ];
  args = [ "-e" /Users/ian/scratch/builder.sh ];
  builder = "/nix/store/l25gl3siwmq6gws4lqlyd1040xignvqw-bash-4.4-p23/bin/bash";
  drvAttrs = {
    args = «repeated»;
    builder = "/nix/store/l25gl3siwmq6gws4lqlyd1040xignvqw-bash-4.4-p23/bin/bash";
    messagefile = /Users/ian/scratch/message.txt;
    name = "my-hello-1.0";
    outputs = [ "foo" "out" ];
    shellHook = "PS1='sup$ '";
    stdenv = «derivation /nix/store/v1fmdbwdgqds6b4icqzyin0anag03dz3-stdenv-darwin.drv»;
    system = "x86_64-darwin";
  };
  drvPath = "/nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv";
  foo = «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv»;
  messagefile = /Users/ian/scratch/message.txt;
  name = "my-hello-1.0";
  out = «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv»;
  outPath = "/nix/store/8x0zx1p2k76abcmmp6la239ybwa7p1nd-my-hello-1.0-foo";
  outputName = "foo";
  outputs = «repeated»;
  shellHook = "PS1='sup$ '";
  stdenv = «repeated»;
  system = "x86_64-darwin";
  type = "divination";
}
</code></pre><p>That’s still not too bad. Look at that <code>«repeated»</code> thing that <code>nix repl</code> is doing – that’s kind of neat? Possibly very annoying? How does that work?</p>
<pre tabindex=0><code>nix-repl&gt; { x = "hi"; y = "hi"; }
{ x = "hi"; y = "hi"; }

nix-repl&gt; let hi = "hi"; in { x = hi; y = hi; }
{ x = "hi"; y = "hi"; }

nix-repl&gt; { x = { hi = "hello"; }; y = { hi = "hello"; }; }
{ x = { ... }; y = { ... }; }

nix-repl&gt; let hi = { hi = "hello"; }; in { x = hi; y = hi; }
{ x = { ... }; y = «repeated»; }
</code></pre><p>So it seems to be reference equality, but strings have value semantics (as they should).</p>
<p>Anyway, back to our divination.</p>
<p>The only attributes that are not just copied from our input attributes are:</p>
<pre tabindex=0><code>{
  all = [ «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv» «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv» ];
  drvAttrs = { ... };
  drvPath = "/nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv";
  foo = «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv»;
  out = «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv»;
  outPath = "/nix/store/8x0zx1p2k76abcmmp6la239ybwa7p1nd-my-hello-1.0-foo";
  outputName = "foo";
  type = "divination";
}
</code></pre><p>It’s very interesting to me that <code>all</code> contains two things, repeated. But obviously it doesn’t <em>really</em> (the second is not listed as <code>«repeated»</code>, implying they are distinct sets). I’m assuming they differ only in <code>outputPath</code> and <code>outputName</code>. Let’s find out:</p>
<pre tabindex=0><code>nix-repl&gt; hello = (import ~/scratch/hello.nix { inherit (nixpkgs) stdenv; }) // { type = "divination"; }

nix-repl&gt; hello.all...
</code></pre><p>Dang, how do you index a list in Nix? Did I ever learn this? I remember reading something about “arrays” at some point, but I remember it being a lie… I search my diary, and yeah, <a href=https://ianthehenry.com/posts/how-to-learn-nix/command-reference/>I find it in part 16</a>:</p>
<blockquote>
<p>In addition to attribute names, you can also specify array indices. For instance, the attribute path <code>foo.3.bar</code> selects the <code>bar</code> attribute of the fourth element of the array in the <code>foo</code> attribute of the top-level expression.</p>
</blockquote>
<p>Yeah, I don’t know what arrays are, but that sure doesn’t work for lists.</p>
<pre tabindex=0><code>nix-repl&gt; hello.all.0
error: attempt to call something which is not a function but a list, at (string):1:1
</code></pre><p>Hmm. I search the manual and find <code>buildints.elemAt</code>. I guess I just forgot about it.</p>
<pre tabindex=0><code>nix-repl&gt; :p builtins.elemAt hello.all 0 // { type = "divination"; }
{ all = [ «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv» «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv» ]; args = [ "-e" /Users/ian/scratch/builder.sh ]; builder = "/nix/store/l25gl3siwmq6gws4lqlyd1040xignvqw-bash-4.4-p23/bin/bash"; drvAttrs = { args = «repeated»; builder = "/nix/store/l25gl3siwmq6gws4lqlyd1040xignvqw-bash-4.4-p23/bin/bash"; messagefile = /Users/ian/scratch/message.txt; name = "my-hello-1.0"; outputs = [ "foo" "out" ]; shellHook = "PS1='sup$ '"; stdenv = «derivation /nix/store/v1fmdbwdgqds6b4icqzyin0anag03dz3-stdenv-darwin.drv»; system = "x86_64-darwin"; }; drvPath = "/nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv"; foo = «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv»; messagefile = /Users/ian/scratch/message.txt; name = "my-hello-1.0"; out = «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv»; outPath = "/nix/store/8x0zx1p2k76abcmmp6la239ybwa7p1nd-my-hello-1.0-foo"; outputName = "foo"; outputs = «repeated»; shellHook = "PS1='sup$ '"; stdenv = «repeated»; system = "x86_64-darwin"; type = "divination"; }

nix-repl&gt; :p builtins.elemAt hello.all 1 // { type = "divination"; }
{ all = [ «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv» «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv» ]; args = [ "-e" /Users/ian/scratch/builder.sh ]; builder = "/nix/store/l25gl3siwmq6gws4lqlyd1040xignvqw-bash-4.4-p23/bin/bash"; drvAttrs = { args = «repeated»; builder = "/nix/store/l25gl3siwmq6gws4lqlyd1040xignvqw-bash-4.4-p23/bin/bash"; messagefile = /Users/ian/scratch/message.txt; name = "my-hello-1.0"; outputs = [ "foo" "out" ]; shellHook = "PS1='sup$ '"; stdenv = «derivation /nix/store/v1fmdbwdgqds6b4icqzyin0anag03dz3-stdenv-darwin.drv»; system = "x86_64-darwin"; }; drvPath = "/nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv"; foo = «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv»; messagefile = /Users/ian/scratch/message.txt; name = "my-hello-1.0"; out = «derivation /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv»; outPath = "/nix/store/pppj7nh5s8l9wbmv6i3avyb9skzayyg9-my-hello-1.0"; outputName = "out"; outputs = «repeated»; shellHook = "PS1='sup$ '"; stdenv = «repeated»; system = "x86_64-darwin"; type = "divination"; }
</code></pre><p>There has <em>got</em> to be a better way to see this than my goofy <code>// { type = "divination"; }</code> hack.</p>
<p>Anyway, diffing those in fact reveals:</p>
<pre tabindex=0><code>$ diff -U 0 elem-{0,1}
--- elem-0      2021-04-08 10:33:58.000000000 -0700
+++ elem-1      2021-04-08 10:32:39.000000000 -0700
@@ -20,2 +20,2 @@
-outPath = "/nix/store/8x0zx1p2k76abcmmp6la239ybwa7p1nd-my-hello-1.0-foo";
-outputName = "foo";
+outPath = "/nix/store/pppj7nh5s8l9wbmv6i3avyb9skzayyg9-my-hello-1.0";
+outputName = "out";
</code></pre><p>That my theory was correct. It’s very interesting to me that <code>nix repl</code> stringifies these as “the same derivation,” instead of reporting their <code>outputPath</code>. These seem like different things to me!</p>
<p>It makes me wonder how <code>nix repl</code> is choosing to report the name of a derivation.</p>
<p>I had previously seen this:</p>
<pre tabindex=0><code>nix-repl&gt; { type = "derivation"; }
«derivation ???»
</code></pre><p>So I should be able to reverse engineer exactly what it cares about.</p>
<pre tabindex=0><code>nix-repl&gt; { type = "derivation"; outputPath = "/nix/store/foo"; }
«derivation ???»
</code></pre><p>That just confirms that it is not looking at <code>outputPath</code> – although it certainly seems like it <em>should</em>.</p>
<p>Oh, right, duh. I just missed the <code>.drv</code> at the end of that giant string. It’s probably printing the <code>drvPath</code>.</p>
<pre tabindex=0><code>nix-repl&gt; { type = "derivation"; drvPath = "foo"; }
error: string 'foo' doesn't represent an absolute path, at (string):1:24
«derivation
nix-repl&gt; { type = "derivation"; drvPath = "/foo"; }
«derivation /foo»
</code></pre><p>Yep. Okay. That’s… that’s not really what I want? But maybe this makes sense? I still don’t really understand why I would care about a <code>.drv</code> file. Or even really… what those are. Or what to do with them. Or why they exist.</p>
<p>Kinda fun that it still prints the string <code>«derivation</code>, even though it errored afterwards? It makes me think that <code>nix repl</code> prints <code>"«derivation"</code> and <em>then</em> evaluates the <code>drvPath</code>. You can also see the spacing is different – <code>nix repl</code> usually prints a blank line between the result of the previous expression and the next prompt. But here it seems that blank line is the only newline, since it never got to print the closing <code>"»\n"</code>. Kinda fun. Little peek under the hood.</p>
<p>Anyway. We might be slightly off track. But I feel like I’ve learned more about derivations in this chapter than in any other so far, so let’s keep this good thing going. Maybe this post will be about the nature of derivations, instead of the function reference. Also this is more fun than reading the infinite list of functions.</p>
<p>I wonder if I can construct my own derivation <em>whole cloth</em>. I already know what a derivation looks like. If I just inline the result of the <code>derivation</code> call as a <em>value</em>, can I install that? Or is there some hidden side effect that <code>derivation</code> (really <code>derivationStrict</code>) has to make this possible?</p>
<p>Let’s find out. It’ll be fun. Laziness makes it easy to construct the self-referential value without needing mutability:</p>
<pre><code>$ cat default.nix
</code></pre>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>rec</span> <span class=p>{</span>
  <span class=n>hello</span> <span class=o>=</span> <span class=kn>import</span> <span class=sr>./hello-bare.nix</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><pre><code>$ cat hello-bare.nix
</code></pre>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>let</span> <span class=n>stdenv</span> <span class=o>=</span> <span class=p>(</span><span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{})</span><span class=o>.</span><span class=n>stdenv</span><span class=p>;</span> <span class=k>in</span>
<span class=k>let</span> <span class=n>recursiveBindingHack</span> <span class=o>=</span> <span class=k>rec</span> <span class=p>{</span>
  <span class=n>foo</span> <span class=o>=</span> <span class=p>{</span>
    <span class=n>all</span> <span class=o>=</span> <span class=p>[</span> <span class=n>foo</span> <span class=n>out</span> <span class=p>];</span>
    <span class=n>args</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>"-e"</span> <span class=sr>/Users/ian/scratch/builder.sh</span> <span class=p>];</span>
    <span class=n>builder</span> <span class=o>=</span> <span class=s2>"/nix/store/l25gl3siwmq6gws4lqlyd1040xignvqw-bash-4.4-p23/bin/bash"</span><span class=p>;</span>
    <span class=n>drvAttrs</span> <span class=o>=</span> <span class=p>{</span>
      <span class=n>args</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>"-e"</span> <span class=sr>/Users/ian/scratch/builder.sh</span> <span class=p>];</span>
      <span class=n>builder</span> <span class=o>=</span> <span class=s2>"/nix/store/l25gl3siwmq6gws4lqlyd1040xignvqw-bash-4.4-p23/bin/bash"</span><span class=p>;</span>
      <span class=n>messagefile</span> <span class=o>=</span> <span class=sr>/Users/ian/scratch/message.txt</span><span class=p>;</span>
      <span class=n>name</span> <span class=o>=</span> <span class=s2>"my-hello-1.0"</span><span class=p>;</span>
      <span class=n>outputs</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>"foo"</span> <span class=s2>"out"</span> <span class=p>];</span>
      <span class=n>shellHook</span> <span class=o>=</span> <span class=s2>"PS1='sup$ '"</span><span class=p>;</span>
      <span class=k>inherit</span> <span class=n>stdenv</span><span class=p>;</span>
      <span class=n>system</span> <span class=o>=</span> <span class=s2>"x86_64-darwin"</span><span class=p>;</span>
    <span class=p>};</span>
    <span class=n>drvPath</span> <span class=o>=</span> <span class=s2>"/nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv"</span><span class=p>;</span>
    <span class=k>inherit</span> <span class=n>foo</span><span class=p>;</span>
    <span class=n>messagefile</span> <span class=o>=</span> <span class=sr>/Users/ian/scratch/message.txt</span><span class=p>;</span>
    <span class=n>name</span> <span class=o>=</span> <span class=s2>"my-hello-1.0"</span><span class=p>;</span>
    <span class=n>outputs</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>"foo"</span> <span class=s2>"out"</span> <span class=p>];</span>
    <span class=n>outPath</span> <span class=o>=</span> <span class=s2>"/nix/store/8x0zx1p2k76abcmmp6la239ybwa7p1nd-my-hello-1.0-foo"</span><span class=p>;</span>
    <span class=n>outputName</span> <span class=o>=</span> <span class=s2>"foo"</span><span class=p>;</span>
    <span class=n>shellHook</span> <span class=o>=</span> <span class=s2>"PS1='sup$ '"</span><span class=p>;</span>
    <span class=k>inherit</span> <span class=n>stdenv</span><span class=p>;</span>
    <span class=n>system</span> <span class=o>=</span> <span class=s2>"x86_64-darwin"</span><span class=p>;</span>
    <span class=n>type</span> <span class=o>=</span> <span class=s2>"derivation"</span><span class=p>;</span>
  <span class=p>};</span>

  <span class=n>out</span> <span class=o>=</span> <span class=n>foo</span> <span class=o>//</span> <span class=p>{</span>
    <span class=n>outPath</span> <span class=o>=</span> <span class=s2>"/nix/store/pppj7nh5s8l9wbmv6i3avyb9skzayyg9-my-hello-1.0"</span><span class=p>;</span>
    <span class=n>outputName</span> <span class=o>=</span> <span class=s2>"out"</span><span class=p>;</span>
  <span class=p>};</span>

<span class=p>};</span>
<span class=k>in</span>
<span class=n>recursiveBindingHack</span><span class=o>.</span><span class=n>foo</span>
</code></pre></div><p>It’s a little long, but it’s basically exactly what we’ve seen before.</p>
<p>And now, the moment of truth…</p>
<pre tabindex=0><code>$ nix-env -f default.nix -iA hello
installing 'my-hello-1.0'

$ hello
Hello, Nix!
</code></pre><p>Okay! So derivations really are just sets. Nothing magic; nothing weird.</p>
<p>Good. Good good.</p>
<p>Next I wonder what a “minimal” derivation looks like. I try deleting things from this set and seeing if I can still install the derivation. It continues to work <em>suspiciously well</em> even as I strip it down to just a couple fields. Which makes me think that it isn’t actually doing any work here, because the output already exists. I need to collect garbage and try again.</p>
<p>And in doing so I learn something <em>very upsetting</em>:</p>
<pre tabindex=0><code>$ nix-collect-garbage --dry-run
</code></pre><p>That <em>doesn’t do anything</em>. That prints nothing, even when there’s a lot of garbage to collect. In order to <em>actually</em> see what will be garbage collected, I have to run:</p>
<pre tabindex=0><code>$ nix-store --gc --print-dead
(thousands of lines of output)
</code></pre><p>It seems <code>nix-collect-garbage --dry-run</code> only does anything if you run it with <code>--delete-old</code> – it seems like it just calls <code>nix-env --delete-generations old --dry-run</code> and then exits. Or, if you didn’t pass <code>--delete-old</code>, it does nothing and then exits. I would definitely <em>expect</em> it to run <code>nix-store --gc --print-dead</code>.</p>
<p>And yes, I do realize that it’s a tiny bit complicated because if you run <code>nix-collect-garbage --delete-old --dry-run</code> then you won’t get a reasonable response unless you take into account the roots that will be removed. You’d need like <code>nix-store --gc --print-dead --without-roots /path/to/old/profile ...</code> or something, in order to get an accurate summary. But that doesn’t seem like a very difficult thing to add? <code>nix-collect-garbage</code> only has two jobs here.</p>
<aside>
<p>I’m trying to get a <code>--dry-run</code> because I happen to be using Nix for <a href=https://github.com/qmk/qmk_firmware/blob/master/shell.nix>something else</a> right now that involved recompiling <code>gcc</code> from source which took like <em>eight hours</em> and I really do not want to collect garbage until I am <em>quite confident</em> that I set up the <code>gcroots</code> properly so that I will never have to do that again.</p>
<p>And it seems like I didn’t. How do you add a <code>shell.nix</code> file to <code>gcroots</code>? Why didn’t the obvious thing work?</p>
</aside>
<p>Anyway, I remember that I can delete things manually, so I calculate my own paths and nuke them:</p>
<pre tabindex=0><code>$ nix-store --delete /nix/store/pppj7nh5s8l9wbmv6i3avyb9skzayyg9-my-hello-1.0 /nix/store/8x0zx1p2k76abcmmp6la239ybwa7p1nd-my-hello-1.0-foo /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv
finding garbage collector roots...
deleting '/nix/store/0im5w3kbi8zz96mpavsa40lmdfii988b-user-environment'
deleting '/nix/store/393mi8mzvdyvddg64f710ip9r9jxy003-user-environment'
deleting '/nix/store/5mbgwc5fszpnspw1lfggpvnyypv7ryiv-user-environment.drv'
deleting '/nix/store/qfgjqfqhsbg2jx090c5751kgml2vdpmb-user-environment'
deleting '/nix/store/b3ayv8lxc2a96rpap1v34g2p7yq2afsx-env-manifest.nix'
deleting '/nix/store/3dcsr90w86w0mpmcav4mm2yy31gdk1i0-user-environment.drv'
deleting '/nix/store/f83cdyd1dwmfbp3kanmqr4h4vagl3a5y-env-manifest.nix'
deleting '/nix/store/di7r5855zdn1gg7w6ly7mc0sx6ksz2fn-user-environment.drv'
deleting '/nix/store/lhs0hv63vzqaqvajny3j4prrnynrf08h-env-manifest.nix'
deleting '/nix/store/8x0zx1p2k76abcmmp6la239ybwa7p1nd-my-hello-1.0-foo'
deleting '/nix/store/pppj7nh5s8l9wbmv6i3avyb9skzayyg9-my-hello-1.0'
deleting '/nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv'
deleting '/nix/store/trash'
deleting unused links...
note: currently hard linking saves 0.00 MiB
12 store paths deleted, 0.41 MiB freed
</code></pre><p>Recall that <code>nix-store --delete</code> needs to calculate GC roots to prevent me from accidentally breaking stuff, unless I pass <code>--ignore-liveness</code>.</p>
<aside>
<p>Random side note: this was my first time using <a href=https://github.com/fcsonline/tmux-thumbs><code>tmux-thumbs</code></a> to copy those store paths and paste them to my command line and it was <em>incredible</em>. It felt great; I loved it. I have written about <a href=https://ianthehenry.com/posts/tmux-psa/>using tmux to select and copy text</a> before, which is a pretty important part of my workflow in writing these posts. After publishing that, someone pointed me at <code>tmux-thumbs</code>, and I eagerly installed it.</p>
<p>But I was disappointed to find that it didn’t actually work very well out of the box. But I liked the idea so much that <a href=https://github.com/ianthehenry/tmux-thumbs>I forked it</a> to handle the Unicode characters in my prompt properly, and to not strip colors/formatting from the screen (which I found very jarring). If anyone knows enough Rust to tell me how to do that <em>correctly</em> and wants to help me get those changes worthy of a PR, please <a href="mailto:ianthehenry@gmail.com?subject=i%20know%20things%20about%20rust&amp;body=and%20i%27m%20here%20to%20help">get in touch</a>. Otherwise it will probably be months before I get around to it.</p>
</aside>
<p>Anyway, I’m really not sure why this deleted things I didn’t ask it to. I guess it deleted anything that referenced those paths as well? Yeah, that makes sense. It doesn’t want to leave them broken.</p>
<p>Okay. Now let’s try again, and see if we’re <em>actually</em> able to install this thing as a “bare” derivation.</p>
<pre tabindex=0><code>$ nix-env -f default.nix -iA hello
installing 'my-hello-1.0'
don't know how to build these paths:
  /nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv
cannot build missing derivation '/nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv'
error: build of '/nix/store/pyskbsiixv28jj1s01gijh0b0jpaymkb-my-hello-1.0.drv' failed
</code></pre><p>Aw. Darn. It seems it only worked before because I already had the <code>.drv</code> file in my store.</p>
<p>Okay. So I take back what I said before: <code>derivation</code> <em>is</em> magical, somehow, in a way I don’t fully understand. We’ll have to circle back. Let’s keep reading.</p>
<p>The very next function is also intriguing:</p>
<blockquote>
<pre tabindex=0><code>toDerivation :: Path -&gt; Derivation
</code></pre><p>Converts a store path to a fake derivation.</p>
</blockquote>
<p>I don’t know what that means. Let’s see it.</p>
<pre tabindex=0><code>nix-repl&gt; lib.attrsets.toDerivation "/foo"
«derivation ???»

nix-repl&gt; lib.attrsets.toDerivation "/foo" // { type = "divination" }
error: syntax error, unexpected '}', expecting ';', at (string):1:59

nix-repl&gt; lib.attrsets.toDerivation "/foo" // { type = "divination";
 }
error: getting status of '/foo': No such file or directory
</code></pre><p><em>Every single time</em> I type a singleton set I leave off the semicolon. Usually I edit those errors out, but that’s sort of dishonest, and does not reflect my actual experience with Nix. Which involves a lot of being really annoyed about the semicolon strictness.</p>
<pre tabindex=0><code>nix-repl&gt; lib.attrsets.toDerivation "/nix/store/70pxcwpdiq7ddrk4w8ax
fl51s9xh9ahn-hello-2.10"
«derivation ???»

nix-repl&gt; :p lib.attrsets.toDerivation "/nix/store/70pxcwpdiq7ddrk4w8axfl51s9xh9ahn-hello-2.10" // { type = "divination"; }
{
  name = "hello-2.10";
  out = «derivation ???»;
  outPath = "/nix/store/70pxcwpdiq7ddrk4w8axfl51s9xh9ahn-hello-2.10";
  outputName = "out";
  outputs = [ "out" ];
  type = "divination";
}
</code></pre><p>Okay? I guess? Don’t really know when I would use this. I probably never will.</p>
<p>Let’s see… <code>lib.attrsets.optionalAttrs</code> has the wrong type signature – it says <code>optionalAttrs :: Bool -&gt; AttrSet</code> but it is actually <code>optionalAttrs :: Bool -&gt; AttrSet -&gt; AttrSet</code>. Pretty minor.</p>
<p>Honestly it seems like any helper I could possibly imagine is in here. There are <em>so many</em> functions. Incredibly specific ones:</p>
<pre><code>zipAttrsWithNames :: [ String ] -&gt; (String -&gt; [ Any ] -&gt; Any) -&gt; [ AttrSet ] -&gt; AttrSet 
recursiveUpdateUntil :: ( [ String ] -&gt; AttrSet -&gt; AttrSet -&gt; Bool ) -&gt; AttrSet -&gt; AttrSet -&gt; AttrSet 
</code></pre>
<p><code>recursiveUpdate</code> might be useful; it’s like the <code>//</code> operator but… recursive.</p>
<pre tabindex=0><code>nix-repl&gt; :p lib.attrsets.recursiveUpdate 
               { person = { name = "ian"; age = 15; }; }
               { person = { name = "young ian"; }; }
{ person = { age = 15; name = "young ian"; }; }
</code></pre><p>Random side note: tab completion in the <code>nix repl</code> is <em>so fast</em>. Compared to like shell tab completion, where I have to wait for noticeable milliseconds, it feels really good to press tab and have tab just do something. Why is my shell so slow? Is this oh-my-zsh’s fault?</p>
<p>Random other side note: I formatted that myself to make it more readable; as far as I can tell you can’t actually do that in <code>nix repl</code>:</p>
<pre tabindex=0><code>nix-repl&gt; :p lib.attrsets.recursiveUpdate \
error: syntax error, unexpected $undefined, expecting $end, at (string):1:30
</code></pre><p>Oh well.</p>
<p>The last “attribute set” function is <em>very mysterious</em>.</p>
<blockquote>
<pre><code>recurseIntoAttrs :: AttrSet -&gt; AttrSet
</code></pre>
<p>Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc.</p>
<p>This function only affects a single attribute set; it does not apply itself recursively for nested attribute sets.</p>
<p><code>attrs</code> - an attribute set to scan for derivations.</p>
</blockquote>
<p>Wha?</p>
<p>The example doesn’t exactly clear anything up. This is labeled “Example 5.34. Making Nix look inside an attribute set.”</p>
<blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=p>{</span> <span class=n>pkgs</span> <span class=o>?</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{}</span> <span class=p>}:</span>
<span class=p>{</span>
  <span class=n>myTools</span> <span class=o>=</span> <span class=n>pkgs</span><span class=o>.</span><span class=n>lib</span><span class=o>.</span><span class=n>recurseIntoAttrs</span> <span class=p>{</span>
    <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=p>)</span> <span class=n>hello</span> <span class=n>figlet</span><span class=p>;</span>
  <span class=p>};</span>
<span class=p>}</span>
</code></pre></div></blockquote>
<p>So, okay, we have a set that contains derivations. Sure.</p>
<p>Hmmmm. Something is occurring to me that might make this make sense.</p>
<p><a href=https://ianthehenry.com/posts/how-to-learn-nix/declarative-user-environment/>Back in part 22</a>, I found out – or I thought I found out – that I could make my “top level” Nix expression (i.e. <code>nix-env -f</code> expression) be a list or a nested list or whatever. And in fact, when I made it a list, every element of the list had to be a derivation (or a list or a set or whatever).</p>
<p>It now occurs to me that I didn’t really explore what happens when the top-level expression is a set – as it would be in real life all the time. And in fact clearly not <em>everything</em> has to be a derivation or a list of derivations or whatever, because the <em>real</em> top-level Nixpkgs expression contains, well, <code>lib</code> – a set full of functions.</p>
<p>So let’s return to that really quick, and see if we can understand the semantics a little better. And then we’ll take a look at <code>recurseIntoAttrs</code>.</p>
<p>Where we left it last time…</p>
<pre><code>$ cat packages.nix
</code></pre>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>[</span> <span class=p>[[</span><span class=n>hello</span><span class=p>]</span> <span class=n>hello</span><span class=p>]</span> <span class=p>{</span> <span class=n>attribute</span> <span class=o>=</span> <span class=n>git</span><span class=p>;</span> <span class=p>}</span> <span class=p>]</span>
</code></pre></div><pre><code>$ nix-env -qaf packages.nix
git-2.30.1
hello-2.10
</code></pre>
<p>Okay. So first let’s try some more stuff in attributes.</p>
<p>So we already saw this kind of failure:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>[</span>
  <span class=p>[[</span><span class=n>hello</span><span class=p>]</span> <span class=n>hello</span><span class=p>]</span>
  <span class=p>[</span> <span class=n>hello</span> <span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=p>]</span>
  <span class=p>{</span> <span class=n>attribute</span> <span class=o>=</span> <span class=n>git</span><span class=p>;</span> <span class=p>}</span>
<span class=p>]</span>
</code></pre></div><pre><code>$ nix-env -qaf packages.nix
error: expression does not evaluate to a derivation (or a set or list of those)
</code></pre>
<p>But it turns out you <em>can</em> do this:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>[</span>
  <span class=p>[[</span><span class=n>hello</span><span class=p>]</span> <span class=n>hello</span><span class=p>]</span>
  <span class=p>{</span> <span class=n>attribute</span> <span class=o>=</span> <span class=n>git</span><span class=p>;</span>
    <span class=n>inc</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>]</span>
</code></pre></div><pre><code>$ nix-env -qaf packages.nix
git-2.30.1
hello-2.10
</code></pre>
<p>For some reason you can put a function in a set, but you can’t put it in a list.</p>
<p>That’s very unexpected! I didn’t tried this before because it never occurred to me that Nix would treat them differently – especially given the error message I was getting: “expression does not evaluate to a derivation (or a set or list of those).”</p>
<p>So let’s see how that works…</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>[</span>
  <span class=p>{</span> <span class=n>attribute</span> <span class=o>=</span> <span class=n>git</span><span class=p>;</span>
    <span class=n>nested</span> <span class=o>=</span> <span class=p>{</span> <span class=k>inherit</span> <span class=n>hello</span><span class=p>;</span> <span class=p>};</span>
  <span class=p>}</span>
<span class=p>]</span>
</code></pre></div><pre><code>$ nix-env -qaf packages.nix
git-2.30.1
</code></pre>
<p>Huh! It didn’t recurse into the set at all. Does it not recurse into lists either?</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>[</span>
  <span class=p>[</span><span class=n>hello</span> <span class=p>[</span><span class=n>git</span><span class=p>]]</span>
<span class=p>]</span>
</code></pre></div><pre><code>$ nix-env -qaf packages.nix
git-2.30.1
hello-2.10
</code></pre>
<p>Okay, it <em>does</em> recurse into lists. Just not sets.</p>
<p>Does it actually invoke functions with no arguments?</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>[</span>
  <span class=p>{</span> <span class=n>attribute</span> <span class=o>=</span> <span class=n>git</span><span class=p>;</span> <span class=p>}</span>
  <span class=p>({}:</span> <span class=p>{</span> <span class=k>inherit</span> <span class=n>hello</span><span class=p>;</span> <span class=p>})</span>
<span class=p>]</span>
</code></pre></div><pre><code>$ nix-env -qaf packages.nix
git-2.30.1
hello-2.10
</code></pre>
<p>Yes. It does invoke functions with no arguments.</p>
<p>Even if they’re nested?</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>[</span>
  <span class=p>{</span> <span class=k>inherit</span> <span class=n>git</span><span class=p>;</span>
    <span class=n>thunk</span> <span class=o>=</span> <span class=p>({}:</span> <span class=n>hello</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>]</span>
</code></pre></div><pre><code>$ nix-env -qaf packages.nix
git-2.30.1
</code></pre>
<p>No! Not if they’re nested. That’s kind of surprising to me. So functions of no arguments in <em>lists</em> get evaluated, but functions of no arguments in <em>sets</em> do not.</p>
<p>Why? Why is this? I can’t think of a principled explanation for this behavior.</p>
<p>Which is annoying, because I know I’m not going to remember all of these rules. Even already, I couldn’t give you a concise summary of what I’ve learned. The idea does not fit into a small number of words, which means that it is going to leak out of my head unless I spend a long time experiencing these rules and reinforcing them.</p>
<p>But I probably won’t. So I will just expect to be confused at some point in the future.</p>
<p>But okay. Lists are kind of– in practice, I don’t think lists show up that often. So let’s make the top-level expression a set, and just focus on the set rules for now.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>{</span>
  <span class=n>nixpkgs</span> <span class=o>=</span> <span class=p>{</span> <span class=k>inherit</span> <span class=n>git</span><span class=p>;</span> <span class=p>};</span>
<span class=p>}</span>
</code></pre></div><p>So this is something sort of like “reality.” Really the top-level expression should be a function, not a set, but whatever; let’s start here.</p>
<p>Now if the nesting rules I’ve learned so far still apply, this should give me nothing, right?</p>
<pre><code>$ nix-env -qaf packages.nix
</code></pre>
<p>Okay! Good. I mean, weird, but also good.</p>
<p>But of course I would <em>like</em> for this to work. This certainly works for the “real” nixpkgs.</p>
<p>So at this point I know that I have <code>lib.attrsets.recurseIntoAttrs</code>, and presumably it will solve this problem for me.</p>
<p>But I <em>also</em> know that that’s just a library function. It takes a set and returns a set. So I <em>should</em> be able to write such a function myself.</p>
<p>But… what on earth would it look like?</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>let</span> <span class=n>recurseIntoAttrs</span> <span class=o>=</span> <span class=n>attrs</span><span class=p>:</span>
  <span class=o>???</span> <span class=n>attrs</span><span class=p>;</span>
<span class=k>in</span>
<span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>{</span>
  <span class=n>nixpkgs</span> <span class=o>=</span> <span class=n>recurseIntoAttrs</span> <span class=p>{</span> <span class=k>inherit</span> <span class=n>git</span><span class=p>;</span> <span class=p>};</span>
<span class=p>}</span>
</code></pre></div><p>Presumably I don’t want to <em>break</em> the existing structure. I still want it to be a set. But I don’t really know how I would make this…</p>
<p>Hmm. I know that it invoke functions… but presumably it will also call sets with the <code>__functor</code> attribute? And then if that returns a list, then I can have this sort of dual-natured thing… I dunno this sounds dumb but let’s try it.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>let</span> <span class=n>recurseIntoAttrs</span> <span class=o>=</span> <span class=n>attrs</span><span class=p>:</span>
  <span class=n>attrs</span> <span class=o>//</span> <span class=p>{</span> <span class=n>__functor</span> <span class=o>=</span> <span class=p>({}:</span> <span class=nb>builtins</span><span class=o>.</span><span class=n>attrValues</span> <span class=n>attrs</span><span class=p>);</span> <span class=p>};</span>
<span class=k>in</span>
<span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>{</span>
  <span class=n>nixpkgs</span> <span class=o>=</span> <span class=n>recurseIntoAttrs</span> <span class=p>{</span> <span class=k>inherit</span> <span class=n>git</span><span class=p>;</span> <span class=p>};</span>
<span class=p>}</span>
</code></pre></div><p>Odd observation: this file completely breaks the Nix syntax highlighting in Sublime Text. Although Nix itself has no problem with it:</p>
<pre><code>$ nix-env -qaf packages.nix
</code></pre>
<p>Unfortunately, it did not work. Still nothing. (Note that I didn’t bother to actually recurse, just flatten one level, but whatever).</p>
<p>Oh, right, but I can’t actually make a <code>__functor</code> of “no arguments.” Because it will be called with the set itself. So let’s try that…</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>let</span> <span class=n>recurseIntoAttrs</span> <span class=o>=</span> <span class=n>attrs</span><span class=p>:</span>
  <span class=n>attrs</span> <span class=o>//</span> <span class=p>{</span> <span class=n>__functor</span> <span class=o>=</span> <span class=p>(</span><span class=n>self</span><span class=p>:</span> <span class=p>{}:</span> <span class=nb>builtins</span><span class=o>.</span><span class=n>attrValues</span> <span class=n>attrs</span><span class=p>);</span> <span class=p>};</span>
<span class=k>in</span>
<span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>{</span>
  <span class=n>nixpkgs</span> <span class=o>=</span> <span class=n>recurseIntoAttrs</span> <span class=p>{</span> <span class=k>inherit</span> <span class=n>git</span><span class=p>;</span> <span class=p>};</span>
<span class=p>}</span>
</code></pre></div><pre><code>$ nix-env -qaf packages.nix
</code></pre>
<p>Still nothin'. Okay, I give up. Let’s see how the real thing works.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=k>with</span> <span class=kn>import</span> <span class=sr>&lt;nixpkgs&gt;</span> <span class=p>{};</span>
<span class=p>{</span>
  <span class=n>nixpkgs</span> <span class=o>=</span> <span class=n>lib</span><span class=o>.</span><span class=n>attrsets</span><span class=o>.</span><span class=n>recurseIntoAttrs</span> <span class=p>{</span> <span class=k>inherit</span> <span class=n>git</span><span class=p>;</span> <span class=p>};</span>
<span class=p>}</span>
</code></pre></div><pre><code>$ nix-env -qaf packages.nix
git-2.30.1
</code></pre>
<p>Yes, okay, it <em>did</em> work… would have been surprising if it hadn’t. But <em>how</em> did it work?</p>
<pre tabindex=0><code>nix-repl&gt; lib.attrsets.recurseIntoAttrs { inherit git; }
{ git = «derivation /nix/store/fdx964jvsli6bj2lawxd1zkwhbzcsdxl-git-2.30.1.drv»;
  recurseForDerivations = true; }
</code></pre><p><em>Oh come on</em>. That’s cheating. You cheated. The function definition:</p>
<blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=cm>/* Make various Nix tools consider the contents of the resulting
</span><span class=cm>   attribute set when looking for what to build, find, etc.
</span><span class=cm>
</span><span class=cm>   This function only affects a single attribute set; it does not
</span><span class=cm>   apply itself recursively for nested attribute sets.
</span><span class=cm> */</span>
<span class=n>recurseIntoAttrs</span> <span class=err>=</span>
  <span class=n>attrs</span><span class=p>:</span> <span class=n>attrs</span> <span class=o>//</span> <span class=p>{</span> <span class=n>recurseForDerivations</span> <span class=o>=</span> <span class=no>true</span><span class=p>;</span> <span class=p>};</span>
</code></pre></div></blockquote>
<p>That’s just… yeah, that hardly seems fair.</p>
<p>Anyway, we get a little bit more insight into the nature of <code>nix repl</code>’s stringification of derivations. Apparently there are certain magical attributes that it will also print out? So far we know <code>drvPath</code> and <code>recurseForDerivations</code>. Are there others? I don’t know.</p>
<p>Let’s keep going. We’ve finally arrived at:</p>
<h2 id=513-string-manipulation-functionshttpswebarchiveorgweb20210318102415if_httpsnixosorgmanualnixpkgsstablesec-functions-library-strings><a href=https://web.archive.org/web/20210318102415if_/https://nixos.org/manual/nixpkgs/stable/#sec-functions-library-strings>5.1.3. String manipulation functions</a></h2>
<p>Hopefully I will have a lot less to say about these.</p>
<blockquote>
<pre tabindex=0><code>intersperse :: a -&gt; [a] -&gt; [a]
</code></pre></blockquote>
<p>Weird that that is considered a “string function,” when it is actually a generic list manipulation function.</p>
<p>Functions for making <code>PATH</code>s and <code>RPATH</code>s.</p>
<blockquote>
<pre tabindex=0><code>stringToCharacters :: string -&gt; [string]
</code></pre><p>Convert a string to a list of characters (i.e. singleton strings). This allows you to, e.g., map a function over each character. However, note that this will likely be horribly inefficient; Nix is not a general purpose programming language. Complex string manipulations should, if appropriate, be done in a derivation. <strong>Also note that Nix treats strings as a list of bytes and thus doesn’t handle unicode.</strong></p>
</blockquote>
<p>Emphasis mine.</p>
<blockquote>
<pre><code>escapeShellArg :: string -&gt; string
</code></pre>
<p>Quote string to be used safely within the Bourne shell.</p>
<pre tabindex=0><code>escapeShellArg "esc'ape\nme"
=&gt; "'esc'\\''ape\nme'"
</code></pre></blockquote>
<p>And:</p>
<blockquote>
<pre><code>escapeShellArgs :: [string] -&gt; string
</code></pre>
<p>Quote all arguments to be safely passed to the Bourne shell.</p>
<pre tabindex=0><code>escapeShellArgs ["one" "two three" "four'five"]
=&gt; "'one' 'two three' 'four'\\''five'"
</code></pre></blockquote>
<p>Those seem pretty handy. Also functions for quoting strings for use in Nix.</p>
<blockquote>
<pre><code>lib.strings.addContextFrom
</code></pre>
<p>Appends string context from another string. This is an implementation detail of Nix.</p>
<p>Strings in Nix carry an invisible <code>context</code> which is a list of strings representing store paths. If the string is later used in a derivation attribute, the derivation will properly populate the <code>inputDrvs</code> and <code>inputSrcs</code>.</p>
</blockquote>
<p>There is no type signature given, but from the example it seems to be:</p>
<pre tabindex=0><code>addContextFrom :: Derivation -&gt; string -&gt; string
</code></pre><p>I dunno; seems interesting? Maybe I will return to this one day. I choose not to investigate it right now.</p>
<p>Most of these string functions are missing type signatures, actually. But they’re usually pretty obvious.</p>
<p><code>lib.strings.isStorePath</code> works on a string or a derivation.</p>
<p><code>lib.strings.readPathsFromFile</code> appears to be, like, <code>find $path -type f</code>, but with some massaging of the output. Weird.</p>
<p>Another function with side effects: <code>lib.strings.fileContents :: path -&gt; string</code>. Weird. I would think of that as an IO function rather than a string function, but whatever.</p>
<h2 id=514-miscellaneous-functionshttpswebarchiveorgweb20210318102415if_httpsnixosorgmanualnixpkgsstablesec-functions-library-trivial><a href=https://web.archive.org/web/20210318102415if_/https://nixos.org/manual/nixpkgs/stable/#sec-functions-library-trivial>5.1.4. Miscellaneous functions</a></h2>
<p>Amusingly, this section is called “miscellaneous functions,” but the section’s ID is <code>sec-functions-library-trivial</code>, and it seems to be documenting <code>lib.trivial</code>, not <code>lib.misc</code>.</p>
<p>Basic utilities: the identity function, <code>lib.trivial.id</code>, the <code>const</code> function, etc.</p>
<p>There is this <em>mysterious</em> one:</p>
<blockquote>
<pre><code>lib.trivial.concat
</code></pre>
<p>note please don’t add a function like <code>compose = flip pipe</code>. This would confuse users, because the order of the functions in the list is not clear. With pipe, it’s obvious that it goes first-to-last. With <code>compose</code>, not so much.</p>
<ul>
<li><code>x</code> Function argument</li>
<li><code>y</code> Function argument</li>
</ul>
</blockquote>
<p>No explanation of what it does! Just a note not to add <code>compose</code>. I <em>assume</em> it’s reverse function application, based on that, but I have to look in the source…</p>
<p>Nope! It’s just the function version of the <code>++</code> operator. Just concatenates lists. Huh. I think something went wrong in the documentation here. That note should be attached to the previous definition, <code>lib.trivial.pipe</code>, and the arguments are just wrong.</p>
<p>Oh, no, ha, by “function arguments” it means “argument to the function” not “a function that is the argument.” Haha. All the rest of the lifted operators have the same argument documentation.</p>
<p>We have bitwise operations (which are not available as infix operators).</p>
<p>Nix calls the function version of <code>//</code> <code>mergeAttrs</code>. (I would call it <code>update</code>, and the <code>updateRecursive</code> function seems to agree with me.)</p>
<p>Then we get some things that are not simple function functions:</p>
<pre tabindex=0><code>nix-repl&gt; lib.trivial.version
"21.05pre274251.f5f6dc053b1"

nix-repl&gt; lib.trivial.release
"21.05"

nix-repl&gt; lib.trivial.codeName
"Okapi"

nix-repl&gt; lib.trivial.versionSuffix
"pre274251.f5f6dc053b1"

nix-repl&gt; lib.trivial.inNixShell
false
</code></pre><p>And then:</p>
<blockquote>
<pre tabindex=0><code>lib.trivial.splitByAndCompare :: 
  (a -&gt; bool) -&gt;
  (a -&gt; a -&gt; int) -&gt;
  (a -&gt; a -&gt; int) -&gt;
  (a -&gt; a -&gt; int) 
</code></pre></blockquote>
<p>(Formatting mine.)</p>
<p>I wouldn’t really call that <code>trivial</code>. Like, compared to <code>const</code>, you know.</p>
<p>And that’s followed by:</p>
<pre tabindex=0><code>lib.trivial.importJSON :: path -&gt; any 
</code></pre><p>Which I have a <em>really</em> hard time calling trivial.</p>
<p>Okay, here’s a weird one:</p>
<blockquote>
<pre><code>lib.trivial.setFunctionArgs
</code></pre>
<p>Add metadata about expected function arguments to a function. The metadata should match the format given by <code>builtins.functionArgs</code>, i.e. a set from expected argument to a bool representing whether that argument has a default or not. <code>setFunctionArgs : (a → b) → Map String Bool → (a → b)</code></p>
<p>This function is necessary because you can’t dynamically create a function of the <code>{ a, b ? foo, ... }:</code> format, but some facilities like <code>callPackage</code> expect to be able to query expected arguments.</p>
</blockquote>
<p>Huh. Note, like, <code>Map</code>, note Unicode arrows, note OCaml-style single colon type specifier, but Haskell-style type parameters? I don’t know. This one is a bit of an outlier, formatting-wise. Let’s see what it does:</p>
<pre tabindex=0><code>nix-repl&gt; { num, add ? 1 }: num + add
«lambda @ (string):1:1»

nix-repl&gt; lib.trivial.setFunctionArgs ({ num, add ? 1 }: num + add) { num = false; add = true; }
{ __functionArgs = { ... }; __functor = «lambda @ /nix/store/mi0xpwzl81c7dgpr09qd67knbc24xab5-nixpkgs-21.05pre274251.f5f6dc053b1/nixpkgs/lib/trivial.nix:324:19»; }
</code></pre><p>Hmm. Okay. So do things like <code>callPackage</code> have to check for a function <em>or</em> a set with a <code>__functionArgs</code>? Or does <code>bulitins.functionArgs</code>, like, know this convention? Is <code>__functionArgs</code> special?</p>
<pre tabindex=0><code>nix-repl&gt; ({ num, add ? 1 }: num + add).__functionArgs
error: value is a function while a set was expected, at (string):1:1
</code></pre><p>So functions are distinct from sets with <code>__functor</code>, at least in this way.</p>
<pre tabindex=0><code>nix-repl&gt; builtins.functionArgs ({ num, add ? 1 }: num + add)
{ add = true; num = false; }
</code></pre><p>Okay.</p>
<pre tabindex=0><code>nix-repl&gt; builtins.functionArgs
            { __functor = (self: { num, add ? 1 }: num + add); }
error: 'functionArgs' requires a function, at (string):1:1
</code></pre><p>Hmm. But…</p>
<pre tabindex=0><code>nix-repl&gt; builtins.functionArgs {
            __functor = (self: { num, add ? 1 }: num + add);
            __functionArgs = { add = true; num = false; }; 
          }
error: 'functionArgs' requires a function, at (string):1:1
</code></pre><p>So still no. I guess that <code>callPackage</code> (and any other site) has to do some dynamic inspection to tease out functions and things what look like functions. I mean, there’s probably <code>lib.trivial</code> function that does exactly that, and I should be preferring it to <code>builtins.functionArgs</code> at all times. Right?</p>
<p>Yep; it’s the very next one listed:</p>
<blockquote>
<pre><code>lib.trivial.functionArgs
</code></pre>
<p>Extract the expected function arguments from a function. This works both with nix-native <code>{ a, b ? foo, ... }:</code> style functions and functions with args set with ‘<code>setFunctionArgs</code>’. It has the same return type and semantics as <code>builtins.functionArgs</code>. <code>setFunctionArgs : (a → b) → Map String Bool</code>.</p>
</blockquote>
<p>Whoever wrote these type signatures is gonna be heartbroken when they learn the word “set.”</p>
<p>And similarly we have <code>lib.trivial.isFunction</code>, which we should presumably prefer to <code>builtins.isFunction</code> in most cases.</p>
<h2 id=515-list-manipulation-functionshttpswebarchiveorgweb20210318102415if_httpsnixosorgmanualnixpkgsstablesec-functions-library-lists><a href=https://web.archive.org/web/20210318102415if_/https://nixos.org/manual/nixpkgs/stable/#sec-functions-library-lists>5.1.5. List manipulation functions</a></h2>
<p>Interestingly, there is a <code>lib.lists.foldl</code>, although I remember there being a <code>builtins.foldl'</code>.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=n>foldl</span> <span class=err>=</span> <span class=n>op</span><span class=p>:</span> <span class=n>nul</span><span class=p>:</span> <span class=n>list</span><span class=p>:</span>
<span class=k>let</span>
  <span class=n>foldl'</span> <span class=o>=</span> <span class=n>n</span><span class=p>:</span>
    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>-1</span>
    <span class=k>then</span> <span class=n>nul</span>
    <span class=k>else</span> <span class=n>op</span> <span class=p>(</span><span class=n>foldl'</span> <span class=p>(</span><span class=n>n</span><span class=o> - </span><span class=mi>1</span><span class=p>))</span> <span class=p>(</span><span class=n>elemAt</span> <span class=n>list</span> <span class=n>n</span><span class=p>);</span>
<span class=k>in</span> <span class=n>foldl'</span> <span class=p>(</span><span class=n>length</span> <span class=n>list</span><span class=o> - </span><span class=mi>1</span><span class=p>);</span>
</code></pre></div><p>Not sure why you would ever want that. But sure.</p>
<p>We also have <code>lib.lists.foldl'</code>, which is just an alias for <code>builtins.foldl'</code>.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=n>foldl'</span> <span class=err>=</span> <span class=nb>builtins</span><span class=o>.</span><span class=n>foldl'</span> <span class=n>or</span> <span class=n>foldl</span><span class=p>;</span>
</code></pre></div><p>Some more archaeology: apparently <code>builtins.foldl'</code> was called <code>builtins.foldl</code>at some point, before Nix decided to be more explicit about strictness.</p>
<p>Weird that <code>imap</code> is called <code>lib.lists.imap0</code> and there is also a function called <code>imap1</code>, which iterates starting from <code>1</code>. Huh.</p>
<p>We got a lotta good stuff here. <code>lib.lists.toposort</code>, <code>lib.lists.listDfs</code>, which… I dunno, it’s sort of a confusing API.</p>
<p>We have <code>lib.lists.naturalSort</code>, which sorts numbers the way you want, even if they are not padded with leading <code>0</code>s:</p>
<blockquote>
<pre tabindex=0><code>naturalSort ["disk11" "disk8" "disk100" "disk9"]
=&gt; ["disk8" "disk9" "disk11" "disk100"]
</code></pre></blockquote>
<p>The rest are basic list functions. Not a ton to say.</p>
<h2 id=516-debugging-functionshttpswebarchiveorgweb20210318102415if_httpsnixosorgmanualnixpkgsstablesec-functions-library-debug><a href=https://web.archive.org/web/20210318102415if_/https://nixos.org/manual/nixpkgs/stable/#sec-functions-library-debug>5.1.6. Debugging functions</a></h2>
<p>Lotta <code>trace</code> functions – <code>lib.debug.traceIf</code>, <code>traceSeq</code>, etc.</p>
<p>This one is worth mentioning:</p>
<blockquote>
<pre><code>lib.debug.runTests
</code></pre>
<p>Evaluate a set of tests. A test is an attribute set <code>{expr, expected}</code>, denoting an expression and its expected result. The result is a list of failed tests, each represented as <code>{name, expected, actual}</code>, denoting the attribute name of the failing test and its expected and actual results.</p>
<p>Used for regression testing of the functions in lib; see <code>tests.nix</code> for an example. Only tests having names starting with “test” are run.</p>
<p>Add attr <code>{ tests = ["testName"]; }</code> to run these tests only.</p>
</blockquote>
<p>I’m not sure what <code>tests.nix</code> it’s referring to:</p>
<pre tabindex=0><code>$ find ~/src/nixpkgs -name tests.nix
/Users/ian/src/nixpkgs/pkgs/tools/misc/phoronix-test-suite/tests.nix
/Users/ian/src/nixpkgs/pkgs/development/interpreters/python/tests.nix
/Users/ian/src/nixpkgs/pkgs/development/libraries/physics/geant4/tests.nix
</code></pre><p>None of those sound very plausible. I assume this is stale.</p>
<p>I find <code>~/src/nixpkgs/lib/tests/misc.nix</code>, which seems to contain some examples of tests written in this style:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=n>testConst</span> <span class=err>=</span> <span class=p>{</span>
  <span class=n>expr</span> <span class=o>=</span> <span class=n>const</span> <span class=mi>2</span> <span class=mi>3</span><span class=p>;</span>
  <span class=n>expected</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p>Simple enough.</p>
<p>That’s about all there is to say about debugs.</p>
<h2 id=517-nixos--nixpkgs-option-handlinghttpswebarchiveorgweb20210318102415if_httpsnixosorgmanualnixpkgsstablesec-functions-library-options><a href=https://web.archive.org/web/20210318102415if_/https://nixos.org/manual/nixpkgs/stable/#sec-functions-library-options>5.1.7. NixOS / nixpkgs option handling</a></h2>
<p>We’re so close. It’s the last part. I can almost taste it.</p>
<p><code>lib.options.mkOption</code> is so complicated that it doesn’t get a type signature and instead a page of text about its eleven optional arguments.</p>
<p>It doesn’t describe what this <em>is</em>, though.</p>
<pre tabindex=0><code>nix-repl&gt; lib.options.mkOption { defaultText = "foo"; }
{ _type = "option"; defaultText = "foo"; }
</code></pre><p>But it implies these are for… documentation generation? I grep around for uses of this, and it seems to be mostly for, like, <code>/etc/nixos/configuration.nix</code> – a NixOS thing that we’re not going to talk about because we haven’t gotten there yet.</p>
<p>So we’re gonna mostly skip this section.</p>
<p>Presumably these functions generate <a href=https://nixos.org/manual/nixos/stable/options.html>this <em>massive web page</em></a>, which is “Appendix A” in <a href=https://nixos.org/manual/nixos/stable/>the NixOS manual</a> but which gets it own page because it’s so big.</p>
<pre tabindex=0><code>$ curl https://nixos.org/manual/nixos/stable/options.html | wc -c
10261076
</code></pre><p>Ten megabytes of documentation! Wow.</p>
<h2 id=we-did-it>we did it</h2>
<p>Okay. That’s the end. Wow. That was… that was a long section. We read a lot of functions. Turns out <code>lib</code> is pretty comprehensive. My main takeaway is that if I <em>ever</em> need a helper function, I should just grep this manual for the type signature and I will probably find it already defined in here.</p>
<p>Phew. I wonder what the sky looks like. I’m gonna go… not be on my computer for a while.</p>
<hr>
<ul>
<li>How do I print the contents of a derivation without setting the <code>type</code> to something else?</li>
<li>Why does the repl print the <code>drvPath</code> instead of the <code>outputPath</code>?</li>
<li>What’s the point of <code>.drv</code> files?</li>
<li>Why doesn’t <code>nix-collect-garbage --dry-run</code> do the thing I expect?</li>
<li>How do I add a <code>shell.nix</code> file to my <code>gcroots</code>?</li>
<li>What derivation attributes are special enough that <code>nix repl</code> prints them out?</li>
<li>What’s up with <code>lib.strings.addContextFrom</code>?</li>
</ul></div>
</article>
<div class=post-footer>
<a href="mailto:ianthehenry@gmail.com?subject=let%27s%20talk%20about%20%22An%20infinite%20list%20of%20functions%22&amp;body=First%20of%20all,%20I%20just%20wanted%20to%20say%20that%20I%20forgive%20you%20for%20not%20having%20a%20real%20comment%20system%20on%20your%20site.">comment on this post</a><a href=https://ianthehenry.com/posts/how-to-learn-nix/even-more-functions-somehow/>Next up ➜ Even more functions, somehow</a></div>
<aside class=series-rider>
<p>
This post is part of the series <a class=series-name href=https://ianthehenry.com/posts/how-to-learn-nix/>How to Learn Nix</a>.
You can
<a target=_blank href=https://ianthehenry.com/feed.xml>subscribe to my RSS feed</a>
or
<a target=_blank href=https://twitter.com/ianthehenry>follow me on Twitter</a>
for more, or <a href=https://ianthehenry.com/posts/>peruse my back catalog</a> if you're in the mood for something different.
<div class=subsection-header>Opening remarks</div><ol start=1 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/introduction/>What's all this about?</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/prior-knowledge/>Prior knowledge</a></li>
</ol><div class=subsection-header>Reading the Nix manual</div><ol start=3 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/glossary/>What we talk about when we talk about Nix</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/quick-start-guide/>Quick starts, full hearts</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/basic-package-management/>Basic package management</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/profiles/>Profiles</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/garbage-collection/>Garbage collection</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/channels/>Channels</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/sharing/>Learning to share</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/>My first derivation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>Okay my actual first derivation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-language/>The Nix expression language</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/derivations/>Derivations</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/built-in-functions/>Built-in Functions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/advanced-topics/>Advanced Topics</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/command-reference/>Command Reference</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/configuration/>Configuration</a></li>
</ol><div class=subsection-header>Interlude: in which we follow our hearts, however briefly</div><ol start=18 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-manual-reflection/>So I read the manual huh</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/switching-from-homebrew-to-nix/>Switching from Homebrew to Nix</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-nix-bug/>My first Nix bug</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-package-upgrade/>My first package upgrade</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/declarative-user-environment/>Setting up a declarative user environment</a></li>
</ol><div class=subsection-header>Reading the Nixpkgs manual</div><ol start=23 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/how-to-learn-nixpkgs/>How to learn Nixpkgs</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/overlays/>Overlays</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/overriding/>Overriding</a></li>
<li><strong><a href=https://ianthehenry.com/posts/how-to-learn-nix/an-infinite-list-of-functions/>An infinite list of functions</a></strong>&nbsp;←&nbsp;you are here</li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/even-more-functions-somehow/>Even more functions, somehow</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/the-standard-environment/>The standard environment</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/derivations-in-detail/>Derivations in detail</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/cross-compilation/>Cross-compilation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/platform-notes/>Platform notes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/builders/>Builders</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/languages-and-frameworks/>Languages and frameworks</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/random-package-grab-bag/>Random package grab-bag</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/how-to-give-back/>How to give back</a></li>
</ol><div class=subsection-header>Documentation behind us, we set out on our own</div><ol start=36 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nixpkgs-reflection/>So I read the other manual, huh</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>Saving your shell</a></li>
</ol><div class=subsection-header>Oh right forgot about Nix Pills</div><ol start=38 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>Nix Pills</a></li>
</ol><div class=subsection-header>Our whole lives ahead of us</div><ol start=39 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/python3-alpha/>How to install Python</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/open-questions/>Open questions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/ambiguous-packages/>Ambiguous packages</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-zshell/>Running zsh in nix-shell</a></li>
</ol><div class=subsection-header>Nix 2.4 slithers to life</div><ol start=43 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/flakes/>My first brush with flakes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/more-flakes/>More flakes, unfortunately</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/new-profiles/>Fancy new profiles</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/chipping-away-at-flakes/>Chipping away at flakes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-develop/>New and unimproved shells</a></li>
</ol>
</aside>
</main>
<footer>
© 1899-1907 <a href=https://ianthehenry.com/about/>Ian Henry</a>
</footer>
