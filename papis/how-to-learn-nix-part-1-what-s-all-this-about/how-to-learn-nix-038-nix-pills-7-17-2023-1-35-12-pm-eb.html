<!DOCTYPE html> <html lang=en style><!--
 Page saved with SingleFile 
 url: https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/ 
 saved date: Mon Jul 17 2023 13:35:12 GMT+0600 (Kyrgyzstan Time)
--><meta charset=utf-8>
<meta name=viewport content="initial-scale=1,maximum-scale=1">
<title>How to Learn Nix, Part 38: Nix Pills</title>
<link rel=canonical href=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>
<style>:root{--box-radius:6px;--outer-box-radius:10px}:root{--content-bg:#fff;--gutter-bg:#eeeef3;--text-fg:#4d4d4c;--table-border-color:#ccc;--separator-color:#6d6d6c;--link:#07c;--link-visited:#751a9a;--blockquote-accent:var(--link);--footnote-accent:#ffd2a3;--subscribe-button-bg:#44e66c;--subscribe-button-fg:#11391b;--media-controls-on:#34b553;--media-controls-contrast:#fff;--inline-code-bg:#f3f3fa;--code-block-bg:#f3f3fa;--aside-bg:#f3f3fa;--aside-warning-bg:#fff5d1;--aside-warning-fg:#ac3233;--palette-red:#c82829;--palette-green:#718c00;--palette-yellow:#eab700;--palette-orange:#f5871f;--palette-blue:#4271ae;--palette-purple:#8959a8;--palette-teal:#3e999f;--palette-white:#fefefe;--palette-black:#000;--palette-text:var(--text-fg);--palette-dim:#8e908c;--highlight-bg:var(--palette-yellow);--highlight-fg:var(--text-fg)}#dmt::before{content:"🌖"}#dmt:hover::before{content:"🌗"}@media (prefers-color-scheme:dark){:root:not(.light-theme){--content-bg:#313233;--gutter-bg:#1d1f21;--text-fg:#d8d4cf;--table-border-color:#ccc;--separator-color:#6d6d6c;--link:rgb(82,183,255);--link-visited:rgb(193,104,229);--blockquote-accent:var(--link);--footnote-accent:#a8612f;--subscribe-button-bg:#44e66c;--subscribe-button-fg:#11391b;--media-controls-on:#44e66c;--media-controls-contrast:#11391b;--inline-code-bg:#3c4044;--code-block-bg:#1d1f21;--aside-bg:#3c4044;--aside-warning-bg:#fff5d1;--aside-warning-fg:var(--palette-red);--palette-red:#cc6666;--palette-green:#b5bd68;--palette-yellow:#f0c674;--palette-orange:#de935f;--palette-blue:#81a2be;--palette-purple:#b294bb;--palette-teal:#8abeb7;--palette-white:#fefefe;--palette-black:#000;--palette-text:var(--text-fg);--palette-dim:#969896;--highlight-bg:var(--palette-yellow);--highlight-fg:var(--palette-black)}:root:not(.light-theme) #dmt::before{content:"🌒"}:root:not(.light-theme) #dmt:hover::before{content:"🌓"}}#dmt{width:30px;text-align:right;padding-right:4px;position:absolute;top:0;bottom:0;right:0;border:none;background-color:inherit;cursor:pointer}*{margin:0;padding:0;font:inherit;box-sizing:border-box}html{background-color:var(--gutter-bg);color:var(--text-fg)}body{font-family:system-ui,sans-serif;font-size:12pt;line-height:1.8;word-wrap:break-word}body:not(.content-page) main>aside{padding:0 var(--content-padding)}body.content-page main,body:not(.content-page) article{background-color:var(--content-bg);border-radius:var(--outer-box-radius);padding:var(--content-padding)}pre{word-wrap:normal}em,i{font-style:italic}sup{font-size:75%}sup a::before{content:"["}sup a::after{content:"]"}h1>a:only-child,h2>a:only-child{display:block}main .subsection-header+.post-list{margin-top:0}strong{font-weight:700}ol,ul{padding-left:3ch}.footnotes>ol{margin-top:1em}.footnotes li:not(.highlight){transition:background-color 1s}hr{border-style:solid;border-width:1.5px 0 0;border-radius:1px;border-color:var(--separator-color)}:not(pre)>code{white-space:pre;background-color:var(--inline-code-bg)}li{padding-left:0}blockquote{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:"";content:none}a,a:active,a:visited{text-decoration:none}a:hover{text-decoration:underline}blockquote{padding:0 0 0 var(--content-padding);border-left:solid 2px var(--blockquote-accent)}aside{--content-padding:0.5em;padding:.5em;border-radius:var(--box-radius);background-color:var(--aside-bg)}a,a:active,header a:visited,footer a:visited,h1 a:visited{color:var(--link)}a:visited{color:var(--link-visited)}a.footnote-ref:visited,a.footnote-backref:visited,.notation-help-link-container a:visited{color:var(--link)}h1{font-size:130%}main *+p,main *+pre,main *+aside,main *+section,main *+article,main *+blockquote,main *+div,main *+ul,main *+ol,main *+hr,main *+h1{margin-top:1em}main pre+div.highlight{margin-top:1px}main .post-header *+h1{margin-top:0}code{font-family:Menlo,monospace;padding:0 3px;border-radius:2px}pre{background-color:var(--code-block-bg);font-size:11pt;padding:calc(.75*var(--content-padding)) var(--content-padding);line-height:1.3;border-radius:var(--box-radius);overflow-x:scroll;-webkit-overflow-scrolling:touch}pre code{padding:0;border-radius:0;display:inline-block;background-color:initial}p+p{margin-top:1em}body{margin:0 auto;--content-padding:10px;max-width:768px;-webkit-text-size-adjust:100%;position:relative}header{position:relative}header>*{height:48px;line-height:48px}.promo,.promo:visited,.promo:active{display:block;text-align:center;background-color:var(--link);color:var(--code-block-bg);border-radius:0 0 var(--outer-box-radius) var(--outer-box-radius)}header .site-title{font-size:130%}header nav{position:absolute;right:30px;top:0}@media all and (max-width:400px){:root{--outer-box-radius:0}header{text-align:center}header nav{position:static}:not(pre)>code{white-space:pre-wrap}body{--content-padding:10px}#dmt{padding:0;text-align:center;width:40px}}header ul{padding:0}header li{list-style:none;display:inline-block}header a{display:block;height:100%}header li+li{margin-left:1em}footer{padding:2em 0;font-size:.85em;text-align:center}article h1.post-title{font-size:200%}article .post-title a{display:block}article .meta{font-size:90%;font-style:italic}.post-header h1{line-height:1.2em;margin-bottom:.5em}.post-footer{text-align:center}.post-footer a{display:block}ol.post-list{list-style-position:inside;padding:0}.series-rider .series-name{font-style:italic}.highlight{color:var(--palette-text)}.highlight .k{color:var(--palette-purple)}.highlight .n{color:var(--palette-text)}.highlight .o{color:var(--palette-teal)}.highlight .p{color:var(--palette-text)}.highlight .c1{color:var(--palette-dim)}.highlight .kn{color:var(--palette-teal)}.highlight .nb{color:var(--palette-text)}.highlight .no{color:var(--palette-red)}.highlight .mi{color:var(--palette-orange)}.highlight .s2{color:var(--palette-green)}.highlight .s1{color:var(--palette-green)}</style>
<meta property=og:title content="How to Learn Nix, Part 38: Nix Pills">
<meta property=og:type content=website>
<meta property=og:url content=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>
<meta name=description content="I don’t know about the word “pills.”
The word “pills” makes me think of medicine; it makes me think of the idiom “a bitter pill to swallow;” it makes me think of sweaters that just came out of the wash. It does not make me think of… documentation, or learning.
I assume that the title is meant to evoke “bite-sized” or something like that. I don’t know. It’s weird a weird choice, for a series.">
<meta property=og:description content="I don’t know about the word “pills.”
The word “pills” makes me think of medicine; it makes me think of the idiom “a bitter pill to swallow;” it makes me think of sweaters that just came out of the wash. It does not make me think of… documentation, or learning.
I assume that the title is meant to evoke “bite-sized” or something like that. I don’t know. It’s weird a weird choice, for a series.">
<meta property=og:image content=https://ianthehenry.com/checkerboard.png>
<meta name=twitter:creator content=@ianthehenry>
<meta name=twitter:card content=summary>
<link type=image/x-icon rel="shortcut icon" href="data:image/vnd.microsoft.icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAHH1uIDShg/xEsZv8GFk3/CSJb/wgZT/8IGU//CBlP/wkiW/8HGE7/CBlP/wkiW/8HIFX/BxhO/wcgVf8OK2t7JDhz/wcfW/8NNn7/CSpq/wkjYf8MJGP/DCJg/w02ef9SqdX/TKHJ/1my2f9Moc3/UqzV/1Cr1v9Pocf/Ditr/xk2cf8KJGL/CjR8/wwva/8RK2r/Cido/w8qa/8LLW//TqjT/1Gnz/9bsNf/Sp/K/1Wt2f9Wrtj/UKjQ/w8xc/8gPHj/Di5w/xk4ef8TL27/Dy5u/xU3fv8QLGv/Ditr/1qy3f9dttv/Yrje/0ecx/9Knsz/U6fQ/1m13f8YN3n/JjZx/wszdv8YOXz/Eilm/xc3e/8dSZT/GDJz/xk/hv9hu+P/WbHZ/1mv1v9Kn8z/WLHd/1212v9ds9n/Eipr/xcqYv8SOX3/GzRz/xQrZ/8aM3D/HEuU/xc0df8fPYD/Yrre/1603P9dt9z/VKvY/1iz4v9etNr/Y73m/xk5fP8cMm3/JEWK/xc0dP8eO3v/Hjd4/ydRnP8WM3P/Gjd3/2bA5/9dtd//Ybng/2K95v9ct+P/Ybnf/2K95/8oS5L/GChg/xxBh/8lSIz/GC5s/yM5ev8hRoz/HTp7/yE6e/9Zsdz/YLzn/2jF7v9ryfL/YLzn/1qu1f9htdz/GDyD/y0/ev9qx/X/acDn/1235v9euun/Yb3r/1665v9owu7/GUOL/yhGh/8nUJL/MkmI/yBFiP8jOHb/MVag/yM+gv8VMGv/acXx/27G7/9szv3/bMb1/2zD6/9vy/X/edf5/yBHjv8yS47/JEuO/zVLiv8nS5D/LkOB/yRXpP8lQoT/H0WI/3fS+P910Pf/b8/8/2bB7/991Pn/eNb+/3nT+P8pS5L/O1GS/ytUnP86UJH/NF2k/zNLjP8sXKv/JkCB/x4+ff+B2/3/etT9/4He//922f//fNf//3TT//991/7/NU6N/zZSkP86Zav/PlWR/zFepv88ZKb/MF2n/yQ/gf8bNXH/fd3//3/b//+K6P//ft///3vV//993f//gdz//0hWlf9FZKX/RmOj/0JXlv9IeMP/QXKz/0Jsuf8eO3z/Hjt2/3vd//+C3v//ju3//3zg//+H4v//guL//4nj//9HXp3/UGur/ztgqf9JYqP/S3G4/05ur/9EbLT/Hjt7/zNJhf+G4///heT//4rq//+E5///iOT//4jr//+G4///UXO0/09iov9EX6H/SWWn/1V5wP9Kaa7/RGSp/ydLj/8NKGCfDShg/x8+d/8RLGb/CBlP/wYWTf8GFEj/CBNH/wooZP8JIlv/CCJd/woWSf8HGE7/ByBV/wwgU/8fO3mfAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
<body class=content-page>
<a class=promo href=https://janet.guide/ target=_blank><i>psst, hey kid, wanna read a weird programming book</i></a>
<header>
<a class=site-title href=https://ianthehenry.com/>Ian Henry</a>
<nav>
<ul><li><a href=https://ianthehenry.com/about/>About</a><li><a href=https://ianthehenry.com/posts/>Blog</a><li><a href=https://ianthehenry.com/stuff/>Stuff</a></ul>
</nav>
<button id=dmt title="Toggle dark mode"></button>
</header>
<main>
<aside class=series-rider>
<p>This post is part of the series <a class=series-name href=https://ianthehenry.com/posts/how-to-learn-nix/>How to Learn Nix</a>, a rambling diary in which I work my way through the Nix manual in excrutiating detail.</p>
</aside>
<article class=post>
<div class=post-header>
<time class=meta datetime=2021-06-05>June 5, 2021</time>
<h1 class=post-title>
<a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>How to Learn Nix, Part&nbsp;38:<br>Nix Pills</a></h1>
</div>
<div class=post-content><p>I don’t know about the word “pills.”</p>
<p>The word “pills” makes me think of medicine; it makes me think of the idiom “a bitter pill to swallow;” it makes me think of sweaters that just came out of the wash. It does not make me think of… documentation, or learning.</p>
<p>I <em>assume</em> that the title is meant to evoke “bite-sized” or something like that. I don’t know. It’s weird a weird choice, for a series.</p>
<p>But it’s distinctive. I’ll give it that. If you say “Nix pills,” people know what you’re talking about. No matter how unsavory the connotation, I suppose it’s well-marketed.</p>
<p>Anyway. <em>Nix Pills</em> started life as a series of blog posts in 2014, written by a real human person writing for the greater good of all humankind, and I already feel a little bad for saying I think the title is weird.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> But it has since become a part of the official documentation – at least, there is an updated(?) version of the blog series hosted on <a href=https://nixos.org/>https://nixos.org</a> and linked to from <a href=https://nixos.org/learn.html>the official “Learn” page</a>, so I’m calling it official documentation, and I’m gonna read it.</p>
<p>But… the audience of the Pills series appears to be someone who has not encountered Nix before. And I have been encountering Nix for the better part of four months now, so I am not really going to be a good judge of what’s confusing, what could be clearer, etc. In other words, I am not really doing this to audit the documentation – I don’t have any intention of trying to improve these blog posts from 2014 – but rather because I think I might learn something.</p>
<p>So this is going to go a lot faster than a typical post: most of these concepts are things that I’ve encountered before.</p>
<p>Let’s dive in.</p>
<h1 id=chapter-1-why-you-should-give-it-a-try>Chapter 1. Why You Should Give it a Try</h1>
<p>Most of this chapter is concerned with extolling the virtues of Nix and motivating the series itself; there is little in the way of information for an existing Nix user.</p>
<blockquote>
<p>This series aims to complement the existing explanations from the more formal documents.</p>
</blockquote>
<p>This is interesting. I’ve heard Nix Pills described as a “textbook, from first principles” approach to explaining Nix – i.e., something I would consider more traditionally formal than the actual manuals. Which didn’t seem very formal at all. But maybe they were more so, when this was written?</p>
<blockquote>
<p>Considering Nixpkgs is a completely new repository of all the existing software, with a completely fresh concept, and with few core developers but overall year-over-year increasing contributions, the current state is more than acceptable and beyond the experimental stage. In other words, it’s worth your investment.</p>
</blockquote>
<p>It is weird to think of Nixpkgs – one of the largest package repositories in the world – as being new in 2014. 2014 wasn’t that long ago! But I look through the Nixpkgs history, and see that the first commit was created in 2003. Okay. That’s closer to what I expected. Using the term to mean novel, I suppose.</p>
<h1 id=chapter-2-install-on-your-running-system>Chapter 2. Install on Your Running System</h1>
<p>Installation. Actually our first nugget of information:</p>
<blockquote>
<p>Yes, Nix also has a database. It’s stored under <code>/nix/var/nix/db</code>. It is a sqlite database that keeps track of the dependencies between derivations.</p>
<p>The schema is very simple: there’s a table of valid paths, mapping from an auto increment integer to a store path.</p>
<p>Then there’s a dependency relation from path to paths upon which they depend.</p>
<p>You can inspect the database by installing <code>sqlite</code> (<code>nix-env -iA sqlite -f '&lt;nixpkgs&gt;'</code>) and then running <code>sqlite3 /nix/var/nix/db/db.sqlite</code>.</p>
</blockquote>
<p>I don’t remember the manual ever describing where to find the database, or what was in it, or really anything about it. It’s nice to call that out up front. It doesn’t really explain <em>why</em> the database exists, but this is just the installation chapter – perhaps it will go into more detail later (although it’s already gone into more detail than the manual ever did).</p>
<p>Apparently this chapter is quite a bit more than installation. It describes the user environment used by <code>nix-env</code> commands, it describes channels and Nixpkgs. It even teases:</p>
<blockquote>
<p>We’ll talk about <code>manifest.nix</code> more in the next article.</p>
</blockquote>
<p>Neat! That’s something I still don’t <em>totally</em> understand, and that the manual certainly never explained.</p>
<h1 id=chapter-3-enter-the-environment>Chapter 3. Enter the Environment</h1>
<p>Explains that a user environment is a directly full of symlinks to every file in all of your installed derivations, which I think is very useful to point out: that was something I did not understand from reading the manual, and <a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>had to discover for myself</a> in the process of installing the first derivation I wrote.</p>
<blockquote>
<p>There isn’t anything like apt which solves a SAT problem in order to satisfy dependencies with lower and upper bounds on versions. There’s no need for this because all the dependencies are static: if a derivation X depends on a derivation Y, then it always depends on it. A version of X which depended on Z would be a different derivation.</p>
</blockquote>
<p>This is a pretty important statement. Because Nix can have multiple versions of a package installed at once, there’s no need to have version bounds. Chapter one made this point as well, but it feels worth repeating.</p>
<blockquote>
<p>The <code>manifest.nix</code> file contains metadata about the environment, such as which derivations are installed. So that <code>nix-env</code> can list, upgrade or remove them. And yet again, the current <code>manifest.nix</code> can be found at <code>~/.nix-profile/manifest.nix</code>.</p>
</blockquote>
<p>That’s interesting: so presumably <code>nix-env -q</code> operates by looking at <code>manifest.nix</code>. I wonder what that file actually looks like. I feel like I could understand it now…</p>
<pre><code>$ cat ~/scratch/ugh.nix
(import &lt;nixpkgs&gt; {}).lib.generators.toPretty { multiline = true; } (import /Users/ian/.nix-profile/manifest.nix)

$ nix-instantiate --eval --strict ~/scratch/ugh.nix
error: attribute 'drvPath' missing, at /nix/store/4rvsrjbd2f351zgdh38as0xzwrlmvzkm-nixpkgs-21.05pre287374.1c16013bd6e/nixpkgs/lib/generators.nix:251:24
</code></pre>
<p>Hmm. No. The <code>toPretty</code> function seems to assume that any record with <code>{ type = "derivation"; }</code> must also have a <code>drvPath</code>. Which is not… looking at the source here, it seems this is <em>not</em> going to pretty-print an expression, but give me output like <code>&lt;derivation /nix/store/whatever&gt;</code>. I don’t want that. It’s a set. Just… just pretty-print it, please…</p>
<p>And no, there is no option to enable that behavior.</p>
<p>So… I still have no idea how to pretty-print a Nix expression, without resorting to third-party tools.</p>
<p>But I’ve read the manuals already. I’m open to the idea of third-party tools, at this point, as I’m pretty sure there is no first-party support. I google, and find something called <a href=https://github.com/nixcloud/nix-beautify><code>nix-beautify</code></a>.</p>
<p>It’s not a part of Nixpkgs, apparently, but there are instructions to install it from their <code>default.nix</code> expression:</p>
<blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>nix-env -i nix-beautify -f https://github.com/nixcloud/nix-beautify/archive/master.tar.gz
</code></pre></div></blockquote>
<p>But I don’t want to install it, of course. I’d rather just <code>nix-shell -p</code> it. But I’ve never done that with anything but <code>nixpkgs</code> before. I know that <code>nix-shell -p</code> doesn’t accept <code>-f</code> and works by <code>-I</code>, so without really thinking about it I try this:</p>
<pre><code>$ nix-shell -p nix-beautify -I nixpkgs=https://github.com/nixcloud/nix-beautify/archive/master.tar.gz
unpacking 'https://github.com/nixcloud/nix-beautify/archive/master.tar.gz'...
[1]    7103 segmentation fault  nix-shell -p nix-beautify -I
</code></pre>
<p>Hmm. I suspect this is because the first thing that <code>default.nix</code> does is <code>import &lt;nixpkgs&gt;</code>, and this causes a stack overflow. Didn’t really think about it, but yeah. Okay.</p>
<p>Fine. I install it, annoyed, and remember to uninstall it afterwards.</p>
<p>Something is weird with my shell completion, though, and I have to manually run <code>rehash</code> after installing it in order to not have to type out the whole executable name. Weird. Can’t remember the last time I had to do that.</p>
<p>Anyway, does it work?</p>
<pre tabindex=0><code>$ nix-beautify manifest.nix

</code></pre><p>It’s just hanging. It’s just hanging there. It can only read from stdin, can’t it.</p>
<pre tabindex=0><code>$ nix-beautify &lt;manifest.nix
(extremely long, unprettified string of Nix expression)
</code></pre><p>Sigh. So that’s… not a thing. Looking at the example in the README, I suspect that this can only <em>indent</em> Nix expressions, not actually… beautify them. Sigh.</p>
<p>I find <a href=https://github.com/Gabriel439/nixfmt>another project</a>, from <a href=https://www.haskellforall.com/>a name I trust</a>. The README is… not reassuring, but it can’t be any worse than <code>nix-beautify</code>. This one is already in nixpkgs, so…</p>
<pre tabindex=0><code>$ nix-shell -p nixfmt

[nix-shell:~]$ nixfmt ~/.nix-profile/manifest.nix
nixfmt: /Users/ian/.nix-profile: openTempFileWithDefaultPermissions: permission denied (Permission denied)
</code></pre><p>Hmmmmm. I suspect this is a symlink issue? Maybe?</p>
<pre tabindex=0><code>[nix-shell:~]$ cp ~/.nix-profile/manifest.nix ~/scratch

[nix-shell:~]$ nixfmt ~/scratch/manifest.nix
</code></pre><p>Ah. No. It literally was permission denied, because this was trying to reformat in-place, instead of just printing out the formatted version. Okay.</p>
<p><em>Well anyway</em> we can now look at the pretty-printed <code>manifest.nix</code>:</p>
<pre><code>$ cat ~/scratch/manifest.nix
</code></pre>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=p>[</span>
  <span class=p>{</span>
    <span class=n>meta</span> <span class=o>=</span> <span class=p>{</span>
      <span class=n>available</span> <span class=o>=</span> <span class=no>true</span><span class=p>;</span>
      <span class=n>broken</span> <span class=o>=</span> <span class=no>false</span><span class=p>;</span>
      <span class=n>changelog</span> <span class=o>=</span>
        <span class=s2>"https://git.savannah.gnu.org/cgit/hello.git/plain/NEWS?h=v2.10"</span><span class=p>;</span>
      <span class=n>description</span> <span class=o>=</span> <span class=s2>"A program that produces a familiar, friendly greeting"</span><span class=p>;</span>
      <span class=n>homepage</span> <span class=o>=</span> <span class=s2>"https://www.gnu.org/software/hello/manual/"</span><span class=p>;</span>
      <span class=n>insecure</span> <span class=o>=</span> <span class=no>false</span><span class=p>;</span>
      <span class=n>license</span> <span class=o>=</span> <span class=p>{</span>
        <span class=n>fullName</span> <span class=o>=</span> <span class=s2>"GNU General Public License v3.0 or later"</span><span class=p>;</span>
        <span class=n>shortName</span> <span class=o>=</span> <span class=s2>"gpl3Plus"</span><span class=p>;</span>
        <span class=n>spdxId</span> <span class=o>=</span> <span class=s2>"GPL-3.0-or-later"</span><span class=p>;</span>
        <span class=n>url</span> <span class=o>=</span> <span class=s2>"https://spdx.org/licenses/GPL-3.0-or-later.html"</span><span class=p>;</span>
      <span class=p>};</span>
      <span class=n>longDescription</span> <span class=o>=</span> <span class=s1>''
</span><span class=s1>        GNU Hello is a program that prints "Hello, world!" when you run it.
</span><span class=s1>        It is fully customizable.
</span><span class=s1>      ''</span><span class=p>;</span>
      <span class=n>maintainers</span> <span class=o>=</span> <span class=p>[{</span>
        <span class=n>email</span> <span class=o>=</span> <span class=s2>"..."</span><span class=p>;</span>
        <span class=n>github</span> <span class=o>=</span> <span class=s2>"edolstra"</span><span class=p>;</span>
        <span class=n>githubId</span> <span class=o>=</span> <span class=mi>1148549</span><span class=p>;</span>
        <span class=n>name</span> <span class=o>=</span> <span class=s2>"Eelco Dolstra"</span><span class=p>;</span>
      <span class=p>}];</span>
      <span class=n>name</span> <span class=o>=</span> <span class=s2>"hello-2.10"</span><span class=p>;</span>
      <span class=n>outputsToInstall</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>"out"</span> <span class=p>];</span>
      <span class=n>platforms</span> <span class=o>=</span> <span class=p>[</span> <span class=o>...</span> <span class=p>];</span>
      <span class=n>position</span> <span class=o>=</span>
        <span class=s2>"/nix/store/4rvsrjbd2f351zgdh38as0xzwrlmvzkm-nixpkgs-21.05pre287374.1c16013bd6e/nixpkgs/pkgs/applications/misc/hello/default.nix:15"</span><span class=p>;</span>
      <span class=n>unfree</span> <span class=o>=</span> <span class=no>false</span><span class=p>;</span>
      <span class=n>unsupported</span> <span class=o>=</span> <span class=no>false</span><span class=p>;</span>
    <span class=p>};</span>
    <span class=n>name</span> <span class=o>=</span> <span class=s2>"hello-2.10"</span><span class=p>;</span>
    <span class=n>out</span> <span class=o>=</span> <span class=p>{</span>
      <span class=n>outPath</span> <span class=o>=</span> <span class=s2>"/nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10"</span><span class=p>;</span>
    <span class=p>};</span>
    <span class=n>outPath</span> <span class=o>=</span> <span class=s2>"/nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10"</span><span class=p>;</span>
    <span class=n>outputs</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>"out"</span> <span class=p>];</span>
    <span class=n>system</span> <span class=o>=</span> <span class=s2>"x86_64-darwin"</span><span class=p>;</span>
    <span class=n>type</span> <span class=o>=</span> <span class=s2>"derivation"</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=o>...</span>
<span class=p>]</span>
</code></pre></div><p>It’s long. Incredibly long. So long that I only included the very first entry, and even then I omitted the <code>platforms</code> key.</p>
<p>So it’s a list of every installed derivation in the environment, and nothing else. Which kind of surprises me – I thought there’d be <em>something</em> in there – but okay. Whatever. Good enough.</p>
<p>What were we talking about?</p>
<h1 id=chapter-4-the-basics-of-the-language>Chapter 4. The Basics of the Language</h1>
<blockquote>
<p>Attempting to perform division in Nix can lead to some surprises.</p>
<pre tabindex=0><code>nix-repl&gt; 6/3
/home/nix/6/3
</code></pre></blockquote>
<p>I’m glad the chapter calls this out. I haven’t made this mistake <em>yet</em>,<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> and I totally understand (and agree with) Nix’s choice, but this is still a gotcha. A very small gotcha, since I imagine you just aren’t doing a lot of division in your Nix expressions, but still worth noting.</p>
<p>Let’s see… points out kebab-case identifiers, something that either wasn’t explained or that I missed when I read the manual. That’s nice.</p>
<p>Talks about string escapes. I remember the manual giving an absolutely <a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-language/>unintelligible description</a> of these:</p>
<blockquote>
<p>Since <code>${</code> and <code>''</code> have special meaning in indented strings, you need a way to quote them. <code>$</code> can be escaped by prefixing it with <code>''</code> (that is, two single quotes), i.e., <code>''$</code>. <code>''</code> can be escaped by prefixing it with <code>'</code>, i.e., <code>'''</code>. <code>$</code> removes any special meaning from the following <code>$</code>.</p>
</blockquote>
<p>Meanwhile, Nix Pills explains it with an actual example:</p>
<blockquote>
<p>Escaping <code>${...}</code> within double quoted strings is done with the backslash. Within two single quotes, it’s done with <code>''</code>:</p>
<pre tabindex=0><code>nix-repl&gt; "\${foo}"
"${foo}"
nix-repl&gt; ''test ''${foo} test''
"test ${foo} test"
</code></pre></blockquote>
<p>Doesn’t give an example of the “<code>$</code> removes any special meaning from the following <code>$</code>” bit, though. Maybe we can observe that?</p>
<pre tabindex=0><code>nix-repl&gt; ''hello ${world}''
error: undefined variable 'world' at (string):1:11

nix-repl&gt; ''hello $${world}''
"hello $${world}" 
</code></pre><p>Okay. Weird. Not really… I mean I guess it makes sense that it’s different from <code>''${world}</code>, but… huh? It’s weird. It’s a weird thing. It’s weird that there’s a redundant escape syntax. You can get the same result like this:</p>
<pre tabindex=0><code>nix-repl&gt; ''hello $''${world}''
"hello $${world}"
</code></pre><p>Anyway.</p>
<p>I learn from this chapter that you can bind multiple identifiers in a single <code>let</code> expression:</p>
<pre><code>nix-repl&gt; let a = 3; b = 4; in a + b
7
</code></pre>
<p>Which… <em>sort of</em> explains the insane choice to have a semicolon before the <code>in</code>, but not… really. This reminds me of requiring terminal semicolons in attribute sets. Which is to say: why would you do this.</p>
<p>The chapter explains <code>with</code>, but not the weird multiple-scope <code>with</code>-not-shadowing-explicitly-bound-identifiers thing that the manual described.</p>
<p>Laziness gets a couple sentences, but no mention of gotchas or patterns or anything. Just an intro.</p>
<h1 id=chapter-5-functions-and-imports>Chapter 5. Functions and Imports</h1>
<p>Explains currying and function application, which the manual… just didn’t? I don’t remember it talking about that. But maybe I’ve forgotten.</p>
<p>Lotsa function stuff. Pattern matching, optional arguments, etc. Nothing we haven’t seen already.</p>
<p>Talks about <code>import</code>, but no mention of <code>&lt;path&gt;</code> syntax yet. I would probably introduce those around the same time, since most import expressions I’ve seen have been <code>import &lt;nixpkgs&gt;</code>.</p>
<h1 id=chapter-6-our-first-derivation>Chapter 6. Our First Derivation</h1>
<blockquote>
<p>Let’s try to fake the name of the system:</p>
<pre><code>nix-repl&gt; d = derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; }
nix-repl&gt; d
«derivation /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv»
</code></pre>
<p>Oh oh, what’s that? Did it build the derivation? No it didn’t, but <strong>it did create the .drv file</strong>. <code>nix repl</code> does not build derivations unless you tell to do so.</p>
</blockquote>
<p>Whoa. That’s weird. I didn’t really think about… <code>nix repl</code> actually instantiating <code>.drv</code> files. Why…? Why does it do that? Does it actually…?</p>
<pre tabindex=0><code>nix-repl&gt; derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; }
«derivation /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv»

$ cat /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv
Derive([("out","/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname","","")],[],[],"mysystem","mybuilder",[],[("builder","mybuilder"),("name","myname"),("out","/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"),("system","mysystem")])
</code></pre><p>Just… what? What possible use… is this? This feels like a weird implementation leak of the <code>repl</code>. This can’t be intentional, can it? There’s no reason you would ever <em>want</em> this behavior, is there?</p>
<p>Anyway, the chapter spends some time discussing <code>.drv</code> files, which I appreciate. They were given absolutely no treatment in the Nix manual, which is crazy to me.</p>
<p>I learn something very valuable from this: <code>nix show-derivation</code>. Basically a way to pretty-print those horrible “ATerm” files, which is something that <a href=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>I was looking for recently</a>. But it doesn’t just pretty-print it, it also annotates each field with a name, and prints it in JSON – an actual format with actual tools for working with it.</p>
<p>Let’s look at the derivation I was trying to inspect last time, that I ended up <code>sed</code>ing into a sexp just to see it more clearly:</p>
<pre><code>$ nix show-derivation /nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv
{
  "/nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/5i9c80x5h0mjpxwfnj6iz8ykivzjrcyq-nix-shell"
      }
    },
    "inputSrcs": [
      "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh"
    ],
    "inputDrvs": {
      "/nix/store/8mgqiwshdp8pvl7agmi1ls6m2ziwp4ag-stdenv-darwin.drv": [
        "out"
      ],
      "/nix/store/gngpiflribp4h76hz4yrfm68vhs50d23-python3.9-cram-0.7.drv": [
        "out"
      ],
      "/nix/store/s5mjnf3b6nmxpyy640mx0s78zspihn2y-bash-4.4-p23.drv": [
        "out"
      ],
      "/nix/store/sqs3pqphn9jbizwxmp8zvfcfg1lp2prm-souffle-2.0.2.drv": [
        "out"
      ]
    },
    "platform": "x86_64-darwin",
    "builder": "/nix/store/30njb8l701pwnm5ya749fh2cgyc2d70m-bash-4.4-p23/bin/bash",
    "args": [
      "-e",
      "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh"
    ],
    "env": {
      "__darwinAllowLocalNetworking": "",
      "__impureHostDeps": "/bin/sh /usr/lib/libSystem.B.dylib /usr/lib/system/libunc.dylib /dev/zero /dev/random /dev/urandom /bin/sh",
      "__propagatedImpureHostDeps": "",
      "__propagatedSandboxProfile": "",
      "__sandboxProfile": "",
      "buildInputs": "",
      "builder": "/nix/store/30njb8l701pwnm5ya749fh2cgyc2d70m-bash-4.4-p23/bin/bash",
      "configureFlags": "",
      "depsBuildBuild": "",
      "depsBuildBuildPropagated": "",
      "depsBuildTarget": "",
      "depsBuildTargetPropagated": "",
      "depsHostHost": "",
      "depsHostHostPropagated": "",
      "depsTargetTarget": "",
      "depsTargetTargetPropagated": "",
      "doCheck": "",
      "doInstallCheck": "",
      "name": "nix-shell",
      "nativeBuildInputs": "/nix/store/n0wm6l7qk9ygzjd76ashf9xx7f0z3kh6-souffle-2.0.2 /nix/store/axzlbh5ji9pr97mi04f70lizn22bkxj5-python3.9-cram-0.7",
      "nobuildPhase": "echo\necho \"This derivation is not meant to be built, aborting\";\necho\nexit 1\n",
      "out": "/nix/store/5i9c80x5h0mjpxwfnj6iz8ykivzjrcyq-nix-shell",
      "outputs": "out",
      "patches": "",
      "phases": "nobuildPhase",
      "propagatedBuildInputs": "",
      "propagatedNativeBuildInputs": "",
      "shellHook": "",
      "stdenv": "/nix/store/59hdixd6qf2jq5mj0bqiwrhy7621wa7j-stdenv-darwin",
      "strictDeps": "",
      "system": "x86_64-darwin"
    }
  }
}
</code></pre>
<p>Ahhh. Much better. It seems that my guesses were right about the different values, also – <code>inputSrcs</code> and <code>inputDrvs</code>. Nothing about the weird empty strings, but I <em>happened</em> to stumble upon an answer, while <a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>re-reading an old blog post of mine</a>:</p>
<blockquote>
<pre><code>[ ( "out"
, "/nix/store/3x7dwzq014bblazs7kq20p9hyzz0qh8g-hello-2.10.tar.gz"
, "sha256"
, "31e066137a962676e89f69d1b65382de95a7ef7d914b8cb956f41ea72e0f516b"
) ]
</code></pre>
</blockquote>
<aside>
<p>I prettified that… wrong, but whatever.</p>
</aside>
<p>It seems that those values are meaningful only for a “fixed-output derivation,” but instead of just being omitted in that case (as they are in the <code>show-derivation</code> output), they appear as empty strings:</p>
<pre><code>[ ( "out"
  , "/nix/store/5i9c80x5h0mjpxwfnj6iz8ykivzjrcyq-nix-shell"
  , ""
  , ""
  ) ]
</code></pre>
<p>Okay, yeah, I guess it is a tuple – probably, who knows what data types this format allows – but, like, gross.</p>
<p>I’m very glad that this explains these files and why they exist and what they look like. I happened to have gone on this journey myself, but it feels important enough that I wish the manual spent some time explaining it.</p>
<blockquote>
<p>Important: the hash of the out path is based solely on the input derivations in the current version of Nix, not on the contents of the build product. It’s possible however to have content-addressable derivations for e.g. tarballs as we’ll see later on.</p>
</blockquote>
<p>Are they actually content-addressable? I know they’re “fixed output” but… I thought that was just an assertion, not actually reflected in the path itself.</p>
<p>Let’s look at one. Let’s see… I’ve got:</p>
<pre tabindex=0><code>/nix/store/bd5v53gnpwcgdlgq9hc2x8l8xm8rsz9h-pcre-ocaml-7.2.3.tar.gz.drv
</code></pre><p>That sounds like it oughtta be fixed-output.</p>
<pre tabindex=0><code>$ nix show-derivation /nix/store/bd5v53gnpwcgdlgq9hc2x8l8xm8rsz9h-pcre-ocaml-7.2.3.tar.gz.drv \
&gt; | jq '.[] | .outputs'
{
  "out": {
    "path": "/nix/store/67wja6vzp1da9adlbimb6839malmnlm0-pcre-ocaml-7.2.3.tar.gz",
    "hashAlgo": "sha256",
    "hash": "6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0e6f4666"
  }
}
</code></pre><p>So… it’s hard to tell, because one is in hex, and the other is in… checks notes… <code>base32</code>. But my notes also tell me this handy helper:</p>
<pre tabindex=0><code>$ nix to-base32

$ nix to-base32 6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0e6f4666
error: hash '6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0e6f4666' does not include a type

$ nix to-base32 sha256 6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0e6f4666
error: hash 'sha256' does not include a type

$ nix to-base32 --help
Usage: nix to-base32 &lt;FLAGS&gt;... &lt;STRINGS&gt;...

Summary: convert a hash to base-32 representation.

Flags:
      --type &lt;TYPE&gt;  hash algorithm ('md5', 'sha1', 'sha256', or 'sha512')

Note: this program is EXPERIMENTAL and subject to change.
</code></pre><p>Why… does a conversion function need to know the algorithm? Aren’t we just converting bytes into a different representation? What…? Whatever:</p>
<pre tabindex=0><code>$ nix to-base32 --type sha256 6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0e6f4666
0rj6dw79px4sj2kq0iss2nzq3rnsn9wivvc0f44wa1mppr6njfb3
</code></pre><p>Hmm. That’s still more characters than occur in the store path, and it doesn’t seem like the store path is a prefix or anything. So… I’m gonna say it’s not content-addressed? At least not by default. But the chapter did say that it’s only “<em>possible</em>” to have content-addressable derivations. It did not say that fixed-output derivations were content-addressable. So that’s an open question, I guess.</p>
<p>Or I don’t really understand what “content-addressable” means. That’s… not unlikely.</p>
<p>Okay. Overall, this chapter seems <em>great</em>. This is a ton of useful information, most of which did not exist in the manual in any form. I’m not going to write all of my thoughts, but this is certainly something I would recommend new Nix users to read. I can’t really judge how approachable it is, because I already know all these things, but it seems to cover basically everything I had questions about before.</p>
<p>I learned also about the magic value <code>set.outPath</code>:</p>
<pre tabindex=0><code>nix-repl&gt; { outPath = "hello" }
error: syntax error, unexpected '}', expecting ';', at (string):1:21

nix-repl&gt; { outPath = "hello"; }
{ outPath = "hello"; }

nix-repl&gt; builtins.toString { outPath = "hello"; }
"hello"
</code></pre><p>Feels like that’s worth mentioning in a discussion of <code>toString</code>. The manual described the special key <code>__toString</code>, but not this.</p>
<p>We’re going through a lot of stuff without any mention of <code>stdenv</code>, which… might be confusing? I can’t really tell. Like, if this was your <em>absolute first exposure</em>, you wouldn’t have any questions here. But if you’ve seen some Nix before, I could imagine this being confusing because of how different it is to what you’ve already seen? I admire that we’re building up things from scratch, with only Nix, and not really discussing Nixpkgs at all. But it never explicitly <em>says</em> that’s what it’s doing.</p>
<p>I dunno. I shouldn’t speculate on how understandable this is. I have lost all ability to judge that.</p>
<p>I learned this repl idiom:</p>
<pre tabindex=0><code>nix-repl&gt; :l &lt;nixpkgs&gt;
Added 14075 variables.
</code></pre><p>Instead of:</p>
<pre tabindex=0><code>nix-repl&gt; pkgs = import &lt;nixpkgs&gt; {}
</code></pre><p>As I have been doing. That’s a neat trick.</p>
<h1 id=chapter-7-working-derivation>Chapter 7. Working Derivation</h1>
<p>It also took me <a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/>two</a> <a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>posts</a> to get to a working derivation. And I was following the manual!</p>
<p>I dunno; I like this chapter too? This seems good. I don’t learn anything, but I think I would recommend it to others. It starts off in a <code>nix repl</code>, which is kind of neat – declaring inline derivations, building them with <code>:b</code>… it’s weird, sure, but probably a decent first intro? Although I must repeat: it’s not my first intro, so I don’t really know what I’m talking about. And it doesn’t linger there, but moves on quickly to writing a “real” <code>default.nix</code> file.</p>
<blockquote>
<p><code>nix-build</code> does two jobs:</p>
<ul>
<li><code>nix-instantiate</code>: parse and evaluate <code>simple.nix</code> and return the .drv file corresponding to the parsed derivation set</li>
<li><code>nix-store -r</code>: realise the .drv file, which actually builds it.</li>
</ul>
</blockquote>
<p>I think it’s nice to call out the primitive operations when discussing the porcelain. Good work.</p>
<h1 id=chapter-8-generic-builders>Chapter 8. Generic Builders</h1>
<p>Okay. So I think what’s happening here is: Nix Pills is going to walk us through <code>mkDerivation</code> and the <code>$stdenv/setup</code> script, and motivate all of the complexities there, starting from scratch. This sort of gets us started, showing how it puts <code>buildInputs</code> on our <code>PATH</code> and makes <code>sed</code> available by default and all that.</p>
<p>But it doesn’t <em>say</em> that’s what it’s doing. And although I can sort of appreciate that the individual steps here do make sense in isolation, I think that having the end goal in mind would make it all more… concrete.</p>
<h1 id=chapter-9-automatic-runtime-dependencies>Chapter 9. Automatic Runtime Dependencies</h1>
<blockquote>
<p>NAR is the Nix ARchive. First question: why not tar? Why another archiver? Because commonly used archivers are not deterministic. They add padding, they do not sort files, they add timestamps, etc.. Hence NAR, a very simple deterministic archive format being used by Nix for deployment. NARs are also used extensively within Nix itself as we’ll see below.</p>
</blockquote>
<p>That’s actually really nice to call out. I assumed NAR files were <em>something</em> more than just bundles of files. But this makes me think that NARs are just… you know. Just the thing that it says. Why, then, is it called Nix Archive? There’s nothing Nix-specific, there, is there? Hmm.</p>
<blockquote>
<p>Build dependencies are automatically recognized by Nix once they are used in any <code>derivation</code> call, but we never specify what are the runtime dependencies for a derivation.</p>
</blockquote>
<p>Okay. Yes. I’m on board here.</p>
<blockquote>
<p>There’s really black magic involved. It’s something that at first glance makes you think “no, this can’t work in the long term”, but at the same time it works so well that a whole operating system is built on top of this magic.</p>
<p>Steps:</p>
<ol>
<li>Dump the derivation as NAR, a serialization of the derivation output. Works fine whether it’s a single file or a directory.</li>
<li>For each build dependency .drv and its relative out path, search the contents of the NAR for this out path.</li>
<li>If found, then it’s a runtime dependency.</li>
</ol>
</blockquote>
<p>This… does not sound like black magic to me. This sounds like exactly how I would expect it to work.</p>
<p>Actually, I originally expected it would just search for anything that looked like a store path in the output. But as soon as I tried <a href=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>manually adding a text file full of store paths</a> to the store, I realized why that doesn’t make sense: derivations aren’t allowed to get their hands on any random paths. The only way it can <em>know</em> a store path is if that store path is a dependency of the <code>.drv</code> file.</p>
<p>So, okay. This makes me wonder how cross-compilation works, since it sounds like all runtime dependencies are subsets of build-time dependencies, but the architectures might be different… but I guess that doesn’t matter, though? Different architectures are different derivations. Different paths. Not really a problem. Okay.</p>
<p>Now it’s motivating the <code>patchelf</code> and <code>strip</code> thing, by showing how a trivial C program ends up with (by this heuristic) a runtime dependency on <code>gcc</code>. This is actually really great: a better description of why the <code>fixupPhase</code> exists than the Nixpkgs manual gave, if I’m remembering right.</p>
<h1 id=chapter-10-developing-with-nix-shell>Chapter 10. Developing with <code>nix-shell</code></h1>
<blockquote>
<p>First thing to notice, we call <code>nix-shell</code> on a nix expression which returns a derivation. We then enter a new bash shell, but it’s really useless. We expected to have the GNU hello world build inputs available in PATH, including GNU make, but it’s not the case.</p>
<p>But, we have the environment variables that we set in the derivation, like <code>$baseInputs</code>, <code>$buildInputs</code>, <code>$src</code> and so on.</p>
</blockquote>
<p>Innnnteresting. I didn’t really think about the <code>PATH</code> thing before. I guess this is something <code>mkShell</code> gives me? No; looking back on the source, it must be something the standard environment’s <code>shellHook</code> thing?</p>
<p>Hmm.</p>
<p>I feel like this chapter is… not a good intro for a beginner. This is not a good first “how to use Nix.” But it’s a very good “I’ve used Nix a bit, and now I want to go in deeper.”</p>
<p>Anyway, thinking about how little <code>nix-shell</code> actually does makes it <em>even weirder</em> to me that it executes <code>bash</code>. Like, the more generic version of <code>nix-shell</code> is to just execute a <em>different builder</em> with the same environment. Let me pick the builder. It’s already separate in the <code>drv</code> file, right?</p>
<p>Hmm.</p>
<h1 id=chapter-11-garbage-collector>Chapter 11. Garbage Collector</h1>
<p>Doesn’t really add anything over the manual. Talks about adding roots, and indirect roots. No mention of <code>keep-outputs</code>. I didn’t learn anything from this chapter.</p>
<h1 id=chapter-12-inputs-design-pattern>Chapter 12. Inputs Design Pattern</h1>
<p>This chapter is… motivating the idea of making packages take their inputs as function arguments?</p>
<p>This is something that seems so natural to me I wouldn’t have thought to motivate it. But starting from first principles, it is an invention, I guess?</p>
<p>I dunno.</p>
<h1 id=chapter-13-callpackage-design-pattern>Chapter 13. Callpackage Design Pattern</h1>
<p><code>callPackage</code>. It seems a little odd to call this a “design pattern,” just as it felt odd to call… functions a design pattern. It’s a pattern! It’s… I don’t know what “design pattern” means in this day and age, I suppose.</p>
<blockquote>
<p>We renamed the old <code>pkgs</code> of the previous pill to <code>nixpkgs</code>. Our package set is now instead named <code>pkgs</code>. Sorry for the confusion.</p>
</blockquote>
<p>This shouldn’t really… hmm. That’s a weird thing to keep in the “official” mirror of this post. Maybe these chapters haven’t actually changed since the original publication?</p>
<p>Anyway. <code>callPackage</code>. I’ve seen it.</p>
<h1 id=chapter-14-override-design-pattern>Chapter 14. Override Design Pattern</h1>
<p>We walk through an implementation of the <code>override</code> “method.” I don’t really get this. It seems straightforward to me, but I guess that if you’re used to object-oriented languages, it might be weird?</p>
<h1 id=chapter-15-nix-search-paths>Chapter 15. Nix Search Paths</h1>
<p>Explains <code>NIX_PATH</code> and <code>.nix-defexpr</code>. I dunno; this is valuable information, but it also seems like something that you’ve probably already encountered if you made it 15 chapters into this guide. Maybe not! But I dunno. Since we’ve only really talked about writing <code>default.nix</code> files, and not really using <code>nix-env</code> yet, I guess maybe it makes sense to introduce it this late. But the order is not really… I dunno. Seems weird.</p>
<h1 id=chapter-16-nixpkgs-parameters>Chapter 16. Nixpkgs Parameters</h1>
<blockquote>
<p>I’m sure on the wiki or other manuals you’ve read about <code>~/.nixpkgs/config.nix</code> and I’m sure you’ve wondered whether that’s hardcoded in nix. It’s not, it’s in nixpkgs.</p>
</blockquote>
<p>Huh. Mine is <code>~/.config/nixpkgs/config.nix</code>. I’m sure this looks at a million possible files. This section links to a source line in the Nixpkgs repo, but not a specific revision, so of course it refers to something nonsensical now.</p>
<p>I’m not sure if the Nix Pills source lives in the Nixpkgs repo or the Nix repo or what, but keeping this up to date seems silly. Anyway; here’s <a href=https://github.com/NixOS/nixpkgs/blob/6a882635f23e709968e77b584ca452e04c5a4ee4/pkgs/top-level/impure.nix#L25>the source as it stands right now</a>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=c1># Fallback: The contents of the configuration file found at $NIXPKGS_CONFIG or</span>
<span class=c1># $HOME/.config/nixpkgs/config.nix.</span>
<span class=n>config</span> <span class=o>?</span> <span class=k>let</span>
    <span class=n>configFile</span> <span class=o>=</span> <span class=nb>getEnv</span> <span class=s2>"NIXPKGS_CONFIG"</span><span class=p>;</span>
    <span class=n>configFile2</span> <span class=o>=</span> <span class=n>homeDir</span> <span class=o>+</span> <span class=s2>"/.config/nixpkgs/config.nix"</span><span class=p>;</span>
    <span class=n>configFile3</span> <span class=o>=</span> <span class=n>homeDir</span> <span class=o>+</span> <span class=s2>"/.nixpkgs/config.nix"</span><span class=p>;</span> <span class=c1># obsolete</span>
  <span class=k>in</span>
    <span class=k>if</span> <span class=n>configFile</span> <span class=o>!=</span> <span class=s2>""</span> <span class=o>&amp;&amp;</span> <span class=n>pathExists</span> <span class=n>configFile</span> <span class=k>then</span> <span class=kn>import</span> <span class=n>configFile</span>
    <span class=k>else</span> <span class=k>if</span> <span class=n>homeDir</span> <span class=o>!=</span> <span class=s2>""</span> <span class=o>&amp;&amp;</span> <span class=n>pathExists</span> <span class=n>configFile2</span> <span class=k>then</span> <span class=kn>import</span> <span class=n>configFile2</span>
    <span class=k>else</span> <span class=k>if</span> <span class=n>homeDir</span> <span class=o>!=</span> <span class=s2>""</span> <span class=o>&amp;&amp;</span> <span class=n>pathExists</span> <span class=n>configFile3</span> <span class=k>then</span> <span class=kn>import</span> <span class=n>configFile3</span>
    <span class=k>else</span> <span class=p>{}</span>
</code></pre></div><p><code># obsolete</code> indeed, I guess.</p>
<p>Okay. That’s kind of all that’s in this chapter? Seems a little weird. But it’s probably motivating, like, the existence of Nixpkgs, if you’re starting from scratch? But who is starting from that degree of scratch, at this point?</p>
<h1 id=chapter-17-nixpkgs-overriding-packages>Chapter 17. Nixpkgs Overriding Packages</h1>
<p>Talking about “the Nix packages fixpoint” is actually very useful/interesting. But I don’t really think the treatment here… I’m glad it gives an example of <code>fix</code>, I guess. That’s useful. That’s good. I can’t really judge if this is a useful explanation.</p>
<blockquote>
<p>The fixed point with lazy evaluation is crippling but about necessary in a language like Nix. It lets us achieve something similar to what we’d do imperatively.</p>
</blockquote>
<p>This is a weird thing to say. It does not explain what we would do imperatively, or what this lets us achieve, or why it’s crippling. I don’t understand the sentiment this is trying to convey.</p>
<p>I assume that it means imperatively re-assigning properties of a derivation, in a way such that they propagate to other derivations that reference ours. This how a “normal” imperative language with reference semantics would work. It doesn’t say that, though, or really explain why this is equivalent. So, I don’t know.</p>
<blockquote>
<p>Whereas in an imperative setting, like with other package managers, a library is installed replacing the old version and applications will use it, in Nix it’s not that straight and simple. But it’s more precise.</p>
</blockquote>
<p>I very mildly object to this statement. I think it’s true; I just think it deserves some justification. The does not really try to substantiate this claim. Anyway. This isn’t interesting.</p>
<p>Okay.</p>
<p>I don’t <em>know</em> if what I’m about to say is true, but I don’t <em>think</em> that this chapter did a very good job of explaining <em>how</em> overrides work to someone who doesn’t already have a good idea of how they work.</p>
<p>It tries more than the official manual does to explain what’s going on, but I have a feeling the explanation here would leave a newcomer to lazy evaluation more confused than when they started. Or maybe not! I’m a terrible judge of this now.</p>
<h1 id=chapter-18-nix-store-paths>Chapter 18. Nix Store Paths</h1>
<blockquote>
<p>The way store paths are computed is a little contrived, mostly due to historical reasons. Our reference will be the Nix source code.</p>
</blockquote>
<p>Okay. This seems… not super important to know.</p>
<blockquote>
<p>Finally the comments tell us to compute the base-32 representation of the first 160 bits (truncation) of a sha256 of the above string</p>
</blockquote>
<p>Ah. Maybe this is why my “convert this hash to base32” thing back in chapter 6 didn’t work.</p>
<p>Let’s see… 160 bits = 20 bytes = 40 hex characters, so…</p>
<pre><code>$ nix to-base32 --type sha256 6339694dbeb706c5097180ed1d79b2dae681bf15
error: hash '6339694dbeb706c5097180ed1d79b2dae681bf15' has wrong length for hash type 'sha256'
</code></pre>
<p>Well, yeah, of course it does, but… can’t you just, like, do a base conversion of a number? Why… what?</p>
<p>Anyway; paying more attention to the contents of this chapter, this wouldn’t have worked anyway, because the hash we’re talking about is not the hash of the contents but rather the hash of a string containing the contents. Okay?</p>
<p>My eyes glaze over; I do not understand why it is important to know precisely where these hashes come from. This chapter has not motivated <em>why</em> it’s explaining this, and I am having a hard time coming up with a reason.</p>
<p>Ah, here we go: it walks through a concrete example of a fixed-output derivation. And I learn the <code>--truncate</code> flag to <code>nix hash</code>. Which lets me get all the way there:</p>
<pre tabindex=0><code>$ nix-shell -p coreutils

[nix-shell:~]$ nix-hash --type sha256 --base32 --truncate --flat &lt;(printf 'output:out:sha256:%s:/nix/store:pcre-ocaml-7.2.3.tar.gz' $(echo
 -n 'fixed:out:sha256:6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0
e6f4666' | sha256sum | cut -d' ' -f1))
r24wj6nsw3s9sli2wkfj6nb2rmzr2gbw
</code></pre><p>No. Still not right. Okay. I have exhausted my ability to care. But theoretically, this chapter is telling me that fixed-output paths really are content-addressable. It’s just a weird and convoluted address. Okay.</p>
<p>And that was the whole chapter. Interesting. I mean, it <em>is</em> interesting, to me, how this works, but this is like… this is a deep cut, here. This is not something that anyone needs to know, in order to use Nix. Probably not even to contribute to Nix. This is like… something you can figure out, if you ever actually care. I mean, I recognize that that’s probably what this chapter is: the author wanting to understand this. But for a newcomer’s guide to Nix, this feels pretty unnecessary.</p>
<p>Although… is that the intent of the Nix Pills series? Is this supposed to be a newcomer’s guide? Or did this begin something like my weird series, a chronicle of an the author following the fun, that has since morphed into recommended reading?</p>
<p>I cannot know.</p>
<h1 id=chapter-19-fundamentals-of-stdenv>Chapter 19. Fundamentals of Stdenv</h1>
<blockquote>
<p>Remember our generic <code>builder.sh</code> in Pill 8? It sets up a basic <code>PATH</code>, unpacks the source and runs the usual autotools commands for us.</p>
<p>The <code>stdenv</code> <code>setup</code> file is exactly that. It sets up several environment variables like <code>PATH</code> and creates some helper bash functions to build a package. I invite you to read it, it’s only 860 lines at the time of this writing.</p>
</blockquote>
<p>It is now 1,338 lines long, but, you know, whatever. It’s long. It’s complicated. I looked through it, as a new Nix user, and got very little out of it. Perhaps you will get more out of it? I don’t know. I feel like I get the gist, now, and don’t look through it again.</p>
<p>And here comes the reveal: that the builders we were writing in previous chapters were <em>secretly</em> building up to <code>stdenv/setup</code> all along. That’s sort of all of the information here. It’s a strange presentation order. This is a pretty hard downshift from “implementation details of Nix’s hashing algorithm.”</p>
<h1 id=chapter-20-basic-dependencies-and-hooks>Chapter 20. Basic Dependencies and Hooks</h1>
<p>This chapter begins with a pleasant introduction, followed by this concerning note:</p>
<blockquote>
<aside>
Note: The complexity of the dependencies and hooks infrastructure has increased, over time, to support cross compilation.
</aside>
</blockquote>
<p><em>Has it ever</em>.</p>
<blockquote>
<aside>
Once you learn the core concepts, you will be able to understand the extra complexity. As a starting point, you might want to refer to nixpkgs commit <code>6675f0a5</code>, the last version of stdenv without cross-compilation complexity.
</aside>
</blockquote>
<p>That is probably a very interesting diff to read, actually. Of course I don’t care about <code>6675f0a5</code>, I care about the “child” commits, which is… how do you see that? That is definitely not something I could recite off the top of my head. The internet tells me:</p>
<pre><code>$ git log 6675f0a5..HEAD --ancestry-path --reverse
</code></pre>
<p>To see the commits made after that. Why is <code>--ancestry-path</code> required? I don’t know. I tried to look at the explanation in <code>man git-log</code> and just… wow.</p>
<blockquote>
<p>Suppose you specified <code>foo</code> as the <code>&lt;paths&gt;</code>. We shall call commits that modify <code>foo</code> <code>!TREESAME</code>, and the rest <code>TREESAME</code>. (In a diff filtered for <code>foo</code>, they look different and equal, respectively.)</p>
</blockquote>
<p>I spent five minutes trying to figure out what that parenthetical is trying to tell me, but I have given up.</p>
<p>Anyway. That does show the commits that introduce the cross-compilation <em>stuff</em>, but I don’t actually bother reading the diff. Seems… enormously complicated.</p>
<p>Okay so. What are we doing here? Reading chapter 20. Okay.</p>
<p>We learn about <code>buildInputs</code>. It explains the bash function <code>findInputs</code> in the <code>stdenv/setup</code> script, which adds the <code>bin/</code> directories of our <code>buildInputs</code> to our <code>PATH</code>. It walks through some code that does that, although it’s exactly the code you’d expect.</p>
<p>Next we learn <code>propagatedBuildInputs</code>. This is something I sort of remember learning about, maybe in the Nixpkgs manual, but it was in the extremely complicated cross-compilation section, and I could not actually tell you what it… is. Maybe it was explained well, and I’ve just forgotten? But I do not remember.</p>
<p>The chapter gives a very good explanation, though:</p>
<blockquote>
<p>The <code>buildInputs</code> covers direct dependencies, but what about indirect dependencies where one package needs a second package which needs a third? Nix itself handles this just fine, understanding various dependency closures as covered in previous builds. But what about the conveniences that <code>buildInputs</code> provides, namely accumulating in <code>pkgs</code> environment variable and inclusion of <code>pkg/bin</code> directories on the <code>PATH</code>? For this, <code>stdenv</code> provides the <code>propagatedBuildInputs</code>.</p>
</blockquote>
<p>This is interesting: it describes that this works by actually creating files in the <code>out</code> path, in a special <code>nix-support</code> subdirectory.</p>
<pre><code>$ find /nix/store -name 'nix-support'
(thousands of results)

$ cd /nix/store/m9n29mydxdjvjqj7rw9idwiqhm2bww1d-ghc-8.10.4/nix-support

$ ls
propagated-build-inputs
propagated-target-target-deps

$ cat propagated-build-inputs
/nix/store/47vpv5i10dwfg1cf5wca1k40f982g5fm-clang-wrapper-7.1.0

$ cat propagated-target-target-deps
/nix/store/dy2rb80nvksrcsbm4hggvayzdv8fwvhx-ncurses-6.2 /nix/store/3068jzr60jjd3xagmly4b06nh5kcb0cs-libffi-3.3 /nix/store/w6iysk0w7j8qnzljp8467yw03ppq3bvk-gmp-6.2.1 /nix/store/4gngk4048zq7fcyx9959vhv09pwy4d6h-libiconv-50
</code></pre>
<p>Interesting! So basically, the output path now references on these other packages. We can think of these as being promoted to “runtime” dependencies, although we recognize that Nix does not think in terms like that.</p>
<p>More importantly, the contents of these files can be read back by the <code>stdenv</code> script, such we don’t <em>just</em> put <code>buildInputs</code> in our <code>PATH</code>, but also each of these dependencies, and so on recursively. You get it. I don’t need to explain this.</p>
<blockquote>
<p>in general, a dependency might affect the packages it depends on in arbitrary ways. <em>Arbitrary</em> is the key word here. We could teach <code>setup.sh</code> things about upstream packages like <code>pkg/nix-support/propagated-build-inputs</code>, but not arbitrary interactions.</p>
<p><em>Setup hooks</em> are the basic building block we have for this. In nixpkgs, a “hook” is basically a bash callback, and a setup hook is no exception.</p>
</blockquote>
<p>Okay. I <em>do</em> remember setup hooks, as basically allowing packages to do things to packages that depend on them. So like, yeah, propagating dependencies is a specific case of this, right? That could be implemented as a setup hook. But it’s special-cased by <code>stdenv/setup</code>.</p>
<blockquote>
<p>One can almost think of this as an escape hatch around Nix’s normal isolation guarantees, and the principle that dependencies are immutable and inert. We’re not actually doing something unsafe or modifying dependencies, but we are allowing arbitrary ad-hoc behavior. For this reason, <code>setup-hooks</code> should only be used as a last resort.</p>
</blockquote>
<p>I don’t… follow this reasoning at all. An “escape hatch around … the principle that dependencies are immutable and inert.” I mean, they’re still immutable and inert, right? We didn’t escape that. In no way can this mutate a dependency. And the dependency itself isn’t doing anything; we’re <em>choosing</em> to search for these <code>setup-hook</code> files and run them. This is something we could choose not to do, if we didn’t want to.</p>
<p>I dunno; this doesn’t seem like a “last resort” thing. It seems like a useful tool to have when you need it. Anyway.</p>
<p>Lastly, we learn about environment hooks. So basically… we find every (direct or “propagated”) dependency. And every time we find a dependency, we <em>source</em> its <code>setup-hook</code> file, if it exists. And each <code>setup-hook</code> may or may not register “environment” hooks.</p>
<p>Once we’ve done that for every package, we go through and add each one to our <code>PATH</code>, if it has a <code>bin/</code> directory. And then we invoke every “environment hook” that we have so far – basically, the union of “environment hooks we explicitly defined” and “environment hooks registered by our dependencies' <code>setup-hook</code>s.”</p>
<p>So every dependency gets a chance to see every other dependency, basically.</p>
<p>Why?</p>
<p>The introduction to this section motivated this, before explaining what it was:</p>
<blockquote>
<p>Recall in Pill 12 how we created <code>NIX_CFLAGS_COMPILE</code> for <code>-I</code> flags and <code>NIX_LDFLAGS</code> for <code>-L</code> flags, in a similar manner to how we prepared the <code>PATH</code>.</p>
</blockquote>
<p>I don’t really remember that because I was kind of… skimming, if we’re being honest. Chapter 12 seemed boring.</p>
<blockquote>
<p>One point of ugliness was how anti-modular this was. It makes sense to build the <code>PATH</code> in generic builder, because the <code>PATH</code> is used by the shell, and the generic builder is intrinsically tied to the shell. But <code>-I</code> and <code>-L</code> flags are only relevant to the C compiler. The <code>stdenv</code> isn’t wedded to including a C compiler (though it does by default), and there are other compilers too which may take completely different flags.</p>
</blockquote>
<p>That makes sense. So basically, the derivation for <code>gcc</code> has a <code>setup-hook</code> which registers an <em>environment hook</em> which accumulates include paths to eventually pass as <code>-I</code>. Neat. Okay.</p>
<p>That’s the end!</p>
<p>That’s the end of Nix Pills series. It actually has a “coming soon” teaser at the bottom for the “Next pill,” as every chapter has so far:</p>
<blockquote>
<p>…I’m not sure! We could talk about the additional dependency types and hooks which cross compilation necessitates, building on our knowledge here to cover stdenv as it works today. We could talk about how nixpkgs is bootstrapped. Or we could talk about how <code>localSystem</code> and <code>crossSystem</code> are elaborated into the <code>buildPlatform</code>, <code>hostPlatform</code>, and <code>targetPlatform</code> each bootstrapping stage receives. Let us know which most interests you!</p>
</blockquote>
<p>It’s a shame that the series ended there, because I feel like the author of the Pills could probably explain the cross-compilation stuff more clearly than the Nixpkgs manual did.</p>
<h1 id=we-did-it>We did it</h1>
<p>There we have it! I read the Pills. I know the things, now.</p>
<p>I learned some good stuff. It was definitely not completely redundant with the Nix and Nixpkgs manuals, and I felt that last chapter especially gave a nice treatment of a part of the <code>genericBuilder</code> that was a <em>little</em> buried in the Nixpkgs manual. Or that I just forgot about. And 6 and 7 were just great introductions to defining your own derivation. I <em>think</em>. Hard to really judge, at this point.</p>
<p>Phew. That was a long one. Why did I do this in a single post? Why didn’t I break this up? What was I thinking?</p>
<hr>
<ul>
<li>Why does the repl instantiate <code>.drv</code> files and put them into the actual store?</li>
<li>Is there anything Nix-specific about NAR files?</li>
</ul>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>Something about the lack of attribution and collaborative nature of the Nix and Nixpkgs manual made it easy for me to criticize, even though I do realize there are real people with real feelings who wrote those also. I hope that I haven’t been being mean without thinking about it this entire time.&nbsp;<a href=#fnref:1 class=footnote-backref role=doc-backlink>↩︎</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p>I would never, <em>ever</em> snuggle my operands in actual code, but I could see myself lazily typing that at a repl.&nbsp;<a href=#fnref:2 class=footnote-backref role=doc-backlink>↩︎</a></p>
</li>
</ol>
</section></div>
</article>
<div class=post-footer>
<a href="mailto:ianthehenry@gmail.com?subject=let%27s%20talk%20about%20%22Nix%20Pills%22&amp;body=First%20of%20all,%20I%20just%20wanted%20to%20say%20that%20I%20forgive%20you%20for%20not%20having%20a%20real%20comment%20system%20on%20your%20site.">comment on this post</a><a href=https://ianthehenry.com/posts/how-to-learn-nix/python3-alpha/>Next up ➜ How to install Python</a></div>
<aside class=series-rider>
<p>
This post is part of the series <a class=series-name href=https://ianthehenry.com/posts/how-to-learn-nix/>How to Learn Nix</a>.
You can
<a target=_blank href=https://ianthehenry.com/feed.xml>subscribe to my RSS feed</a>
or
<a target=_blank href=https://twitter.com/ianthehenry>follow me on Twitter</a>
for more, or <a href=https://ianthehenry.com/posts/>peruse my back catalog</a> if you're in the mood for something different.
<div class=subsection-header>Opening remarks</div><ol start=1 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/introduction/>What's all this about?</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/prior-knowledge/>Prior knowledge</a></li>
</ol><div class=subsection-header>Reading the Nix manual</div><ol start=3 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/glossary/>What we talk about when we talk about Nix</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/quick-start-guide/>Quick starts, full hearts</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/basic-package-management/>Basic package management</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/profiles/>Profiles</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/garbage-collection/>Garbage collection</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/channels/>Channels</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/sharing/>Learning to share</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/>My first derivation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>Okay my actual first derivation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-language/>The Nix expression language</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/derivations/>Derivations</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/built-in-functions/>Built-in Functions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/advanced-topics/>Advanced Topics</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/command-reference/>Command Reference</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/configuration/>Configuration</a></li>
</ol><div class=subsection-header>Interlude: in which we follow our hearts, however briefly</div><ol start=18 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-manual-reflection/>So I read the manual huh</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/switching-from-homebrew-to-nix/>Switching from Homebrew to Nix</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-nix-bug/>My first Nix bug</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-package-upgrade/>My first package upgrade</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/declarative-user-environment/>Setting up a declarative user environment</a></li>
</ol><div class=subsection-header>Reading the Nixpkgs manual</div><ol start=23 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/how-to-learn-nixpkgs/>How to learn Nixpkgs</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/overlays/>Overlays</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/overriding/>Overriding</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/an-infinite-list-of-functions/>An infinite list of functions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/even-more-functions-somehow/>Even more functions, somehow</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/the-standard-environment/>The standard environment</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/derivations-in-detail/>Derivations in detail</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/cross-compilation/>Cross-compilation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/platform-notes/>Platform notes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/builders/>Builders</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/languages-and-frameworks/>Languages and frameworks</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/random-package-grab-bag/>Random package grab-bag</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/how-to-give-back/>How to give back</a></li>
</ol><div class=subsection-header>Documentation behind us, we set out on our own</div><ol start=36 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nixpkgs-reflection/>So I read the other manual, huh</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>Saving your shell</a></li>
</ol><div class=subsection-header>Oh right forgot about Nix Pills</div><ol start=38 class=post-list><li><strong><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>Nix Pills</a></strong>&nbsp;←&nbsp;you are here</li>
</ol><div class=subsection-header>Our whole lives ahead of us</div><ol start=39 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/python3-alpha/>How to install Python</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/open-questions/>Open questions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/ambiguous-packages/>Ambiguous packages</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-zshell/>Running zsh in nix-shell</a></li>
</ol><div class=subsection-header>Nix 2.4 slithers to life</div><ol start=43 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/flakes/>My first brush with flakes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/more-flakes/>More flakes, unfortunately</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/new-profiles/>Fancy new profiles</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/chipping-away-at-flakes/>Chipping away at flakes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-develop/>New and unimproved shells</a></li>
</ol>
</aside>
</main>
<footer>
© 1899-1907 <a href=https://ianthehenry.com/about/>Ian Henry</a>
</footer>
